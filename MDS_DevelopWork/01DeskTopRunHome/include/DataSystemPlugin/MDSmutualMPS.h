//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.5
//
// <auto-generated>
//
// Generated from file `MDSmutualMPS.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __MDSmutualMPS_h__
#define __MDSmutualMPS_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 5
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace MDScallMPSService
{

class LoginServiceProxy;
class LoginServiceProxyPrx;
class RegisterService;
class RegisterServicePrx;

}

namespace MPScallMDSService
{

class MDSService;
class MDSServicePrx;

}

namespace MDScallMPSService
{

using ImageData = ::std::vector<::Ice::Byte>;

struct XYZDATA
{
    ::std::string x;
    ::std::string y;
    ::std::string z;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(x, y, z);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace MPScallMDSService
{

struct SysOperPara
{
    int ParamType;
    ::std::string SatID;
    int GIIRSTeleCmdTime;
    int GIIRSTeleCmdPushCycle;
    int AGRITeleCmdPushCycle;
    int AGRITeleCmdTime;
    int RSITeleCmdPushCycle;
    int RSITeleCmdTime;
    ::Ice::Byte GIIRSAMC;
    ::Ice::Byte GIIRSOMC;
    ::Ice::Byte AGRITMC;
    ::Ice::Byte RSIINRFLOW;
    ::Ice::Byte GRIISINRFLOW;
    ::Ice::Byte AGRIAMC;
    ::Ice::Byte AGRIOMC;
    ::Ice::Byte AGRIXINRFLOW;
    ::Ice::Byte GIIRSTMC;
    ::Ice::Byte RSIAMC;
    ::Ice::Byte RSIOMC;
    ::Ice::Byte RSITMC;
    ::Ice::Byte GIIRSNRS;
    ::Ice::Byte AGRINRS;
    ::Ice::Byte RSINRS;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const int&, const int&, const int&, const int&, const int&, const int&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(ParamType, SatID, GIIRSTeleCmdTime, GIIRSTeleCmdPushCycle, AGRITeleCmdPushCycle, AGRITeleCmdTime, RSITeleCmdPushCycle, RSITeleCmdTime, GIIRSAMC, GIIRSOMC, AGRITMC, RSIINRFLOW, GRIISINRFLOW, AGRIAMC, AGRIOMC, AGRIXINRFLOW, GIIRSTMC, RSIAMC, RSIOMC, RSITMC, GIIRSNRS, AGRINRS, RSINRS);
    }
};

struct SatPlatPara
{
    int ParamType;
    ::std::string SatID;
    ::std::string GIIRSTmcTranCh;
    ::std::string AGRITmcTranCh;
    ::std::string FlutterTranCh;
    ::std::string INRDataTranCh;
    ::std::string SatSenserTranCh;
    ::std::string FixedPosRegTranCh;
    ::std::string SEPDataTranCh;
    ::std::string RSIDataTranCh;
    ::std::string AGRIDataTranCh;
    ::std::string GIIRSProDataTranCh;
    ::std::string GIIRSRawDataTranCh;
    ::std::string DataTranRightCh;
    ::std::string DataTranLeftCh;
    ::std::string OrbitConWorkSta;
    ::std::string ImagePositionSta;
    ::std::string SatColScreenFace;
    int NorOrbAngleRange;
    ::std::string FGMWorkStatus;
    ::std::string RADDWorkStatus;
    ::std::string HEPDWorkStatus;
    ::std::string CPDWorkStatus;
    ::std::string RSIWorkStatus;
    ::std::string GIIRSWorkStatus;
    ::std::string AGRIWorkStatus;
    ::std::string SatWorkStatus;
    double OrbitLocation;
    ::std::string RSITmcTranCh;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const double&, const ::std::string&> ice_tuple() const
    {
        return std::tie(ParamType, SatID, GIIRSTmcTranCh, AGRITmcTranCh, FlutterTranCh, INRDataTranCh, SatSenserTranCh, FixedPosRegTranCh, SEPDataTranCh, RSIDataTranCh, AGRIDataTranCh, GIIRSProDataTranCh, GIIRSRawDataTranCh, DataTranRightCh, DataTranLeftCh, OrbitConWorkSta, ImagePositionSta, SatColScreenFace, NorOrbAngleRange, FGMWorkStatus, RADDWorkStatus, HEPDWorkStatus, CPDWorkStatus, RSIWorkStatus, GIIRSWorkStatus, AGRIWorkStatus, SatWorkStatus, OrbitLocation, RSITmcTranCh);
    }
};

struct Task
{
    ::std::string TaskEN;
    ::std::string TaskCN;
    ::std::string TaskCode;
    ::std::string Exdate;
    ::std::string StartTime;
    ::std::string EndTime;
    ::std::string ExStatus;
    ::std::string RealStartTime;
    ::std::string RealEndTime;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(TaskEN, TaskCN, TaskCode, Exdate, StartTime, EndTime, ExStatus, RealStartTime, RealEndTime);
    }
};

using TasksData = ::std::vector<Task>;

using ImageData = ::std::vector<::Ice::Byte>;

struct ErrorLog
{
    ::std::string branchcode;
    ::std::string errorlevel;
    ::std::string status;
    ::std::string time;
    ::std::string taskcode;
    ::std::string message;
    ::std::string errorcode;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(branchcode, errorlevel, status, time, taskcode, message, errorcode);
    }
};

struct TaskStatus
{
    ::std::string branchcode;
    ::std::string taskcode;
    int status;
    ::std::string dealtag;
    ::std::string time;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const int&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(branchcode, taskcode, status, dealtag, time);
    }
};

struct OrbitData
{
    ::std::string x;
    ::std::string y;
    ::std::string z;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(x, y, z);
    }
};

struct FFTDATA
{
    float rolling;
    float pitch;
    float yaw;
    float dipAngle;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(rolling, pitch, yaw, dipAngle);
    }
};

struct PQADATA
{
    ::std::string branch;
    ::std::string taskcode;
    ::std::string time;
    ::std::string Band1;
    ::std::string Band2;
    ::std::string Band3;
    ::std::string Band4;
    ::std::string Band5;
    ::std::string Band6;
    ::std::string Band7;
    ::std::string Band8;
    ::std::string Band9;
    ::std::string Band10;
    ::std::string Band11;
    ::std::string Band12;
    ::std::string Band13;
    ::std::string Band14;
    ::std::string Band15;
    ::std::string Band16;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(branch, taskcode, time, Band1, Band2, Band3, Band4, Band5, Band6, Band7, Band8, Band9, Band10, Band11, Band12, Band13, Band14, Band15, Band16);
    }
};

struct SysLog
{
    ::std::string branchcode;
    ::std::string logattri;
    ::std::string time;
    ::std::string taskcode;
    ::std::string message;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(branchcode, logattri, time, taskcode, message);
    }
};

struct Instruction
{
    ::std::string type;
    ::std::string satcode;
    ::std::string scheduletype;
    ::std::string modifytime;
    ::std::string dealtime;
    ::std::string status;
    ::std::string desc;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(type, satcode, scheduletype, modifytime, dealtime, status, desc);
    }
};

struct Yaoceyaokongsuju
{
    ::std::string FLCX;
    ::std::string XXD;
    ::std::string SDNX;
    ::std::string ZTDNX;
    ::std::string XMa;
    ::std::string XMb;
    ::std::string XMc;
    ::std::string FFTC;
    ::std::string AGRIXBC;
    ::std::string GRRISBC;
    ::std::string GHIBC;
    ::std::string AGRIXTMC;
    ::std::string AGRIXOMC;
    ::std::string AGRIXAMC;
    ::std::string GRRISTMC;
    ::std::string GRRISOMC;
    ::std::string GRRISAMC;
    ::std::string GHITMC;
    ::std::string GHIOMC;
    ::std::string GHIAMC;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(FLCX, XXD, SDNX, ZTDNX, XMa, XMb, XMc, FFTC, AGRIXBC, GRRISBC, GHIBC, AGRIXTMC, AGRIXOMC, AGRIXAMC, GRRISTMC, GRRISOMC, GRRISAMC, GHITMC, GHIOMC, GHIAMC);
    }
};

struct ProgressAnalysis
{
    ::std::string taskCode;
    ::std::string branchCode;
    ::std::string type;
    ::std::string current;
    ::std::string total;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(taskCode, branchCode, type, current, total);
    }
};

struct ProgressAllAnalysis
{
    ::std::string taskCode;
    ::std::string branchCode;
    ::std::string dwCurrent;
    ::std::string ccyCurrent;
    ::std::string l1aCurrent;
    ::std::string total;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(taskCode, branchCode, dwCurrent, ccyCurrent, l1aCurrent, total);
    }
};

struct BandRegData
{
    ::std::string taskCode;
    ::std::string branchCode;
    ::std::string bandReg;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(taskCode, branchCode, bandReg);
    }
};

struct TaskTime
{
    ::std::string id;
    ::std::string taskcode;
    ::std::string exdate;
    ::std::string l0receivedate;
    ::std::string l1acompletedate;
    ::std::string branchcode;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, taskcode, exdate, l0receivedate, l1acompletedate, branchcode);
    }
};

using TasksTime = ::std::vector<TaskTime>;

struct ErrlrCount
{
    int level1;
    int level2;
    int level3;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(level1, level2, level3);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace MDScallMPSService
{

class LoginServiceProxy : public virtual ::Ice::Object
{
public:

    using ProxyType = LoginServiceProxyPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool LoginAuthentication(::std::string user, ::std::string password, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_LoginAuthentication(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class RegisterService : public virtual ::Ice::Object
{
public:

    using ProxyType = RegisterServicePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool registerModule(::std::string modulename, ::std::string host, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerModule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool unregisterModule(::std::string modulename, ::std::string host, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterModule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData requestImage(::std::string level, ::std::string branchcode, ::std::string registration, ::std::string channel, int left, int right, int top, int bottom, int width, int height, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requestImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void requestTaskList(::std::string day, ::std::string branchcode, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requestTaskList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string requestSysOperPara(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requestSysOperPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string requsetSatPlatPara(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requsetSatPlatPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData requsetYaoCe(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requsetYaoCe(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string requestOrbitData(::std::string time, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requestOrbitData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData getFile(::std::string filename, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getFile(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual XYZDATA requestxyzData(::std::string time, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requestxyzData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace MPScallMDSService
{

class MDSService : public virtual ::Ice::Object
{
public:

    using ProxyType = MDSServicePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void pushUtcTime(::std::string time, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushUtcTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSysOperPara(SysOperPara para, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSysOperPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSatPlatPara(SatPlatPara para, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSatPlatPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTaskInfo(::std::string branchCode, TasksData tasks, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTaskInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void imageReady(::std::string type, ::std::string branch, ::std::string Registration, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_imageReady(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushErrorLog(ErrorLog log, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushErrorLog(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTaskStatus(TaskStatus status, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTaskStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushOrbitData(OrbitData data, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushOrbitData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushFFTData(FFTDATA data, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushFFTData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushPQAData(PQADATA data, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushPQAData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTime(::std::string type, ::std::string branchCode, ::std::string time, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSysLog(SysLog log, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSysLog(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushInstruction(Instruction ins, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushInstruction(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushYaoceyaokongsuju(Yaoceyaokongsuju yaoce, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushYaoceyaokongsuju(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushProgressAnalysis(ProgressAnalysis pa, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushProgressAnalysis(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace MDScallMPSService
{

class LoginServiceProxyPrx : public virtual ::Ice::Proxy<LoginServiceProxyPrx, ::Ice::ObjectPrx>
{
public:

    bool LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LoginServiceProxyPrx::_iceI_LoginAuthentication, user, password, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LoginAuthenticationAsync(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LoginServiceProxyPrx::_iceI_LoginAuthentication, user, password, context);
    }

    ::std::function<void()>
    LoginAuthenticationAsync(const ::std::string& user, const ::std::string& password,
                             ::std::function<void(bool)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::LoginServiceProxyPrx::_iceI_LoginAuthentication, user, password, context);
    }

    /// \cond INTERNAL
    void _iceI_LoginAuthentication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LoginServiceProxyPrx() = default;
    friend ::std::shared_ptr<LoginServiceProxyPrx> IceInternal::createProxy<LoginServiceProxyPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class RegisterServicePrx : public virtual ::Ice::Proxy<RegisterServicePrx, ::Ice::ObjectPrx>
{
public:

    bool registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &RegisterServicePrx::_iceI_registerModule, modulename, host, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerModuleAsync(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &RegisterServicePrx::_iceI_registerModule, modulename, host, context);
    }

    ::std::function<void()>
    registerModuleAsync(const ::std::string& modulename, const ::std::string& host,
                        ::std::function<void(bool)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_registerModule, modulename, host, context);
    }

    /// \cond INTERNAL
    void _iceI_registerModule(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &RegisterServicePrx::_iceI_unregisterModule, modulename, host, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterModuleAsync(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &RegisterServicePrx::_iceI_unregisterModule, modulename, host, context);
    }

    ::std::function<void()>
    unregisterModuleAsync(const ::std::string& modulename, const ::std::string& host,
                          ::std::function<void(bool)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_unregisterModule, modulename, host, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterModule(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ImageData requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, int left, int right, int top, int bottom, int width, int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData>(true, this, &RegisterServicePrx::_iceI_requestImage, level, branchcode, registration, channel, left, right, top, bottom, width, height, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requestImageAsync(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, int left, int right, int top, int bottom, int width, int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MDScallMPSService::ImageData>>().get_future())
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData, P>(false, this, &RegisterServicePrx::_iceI_requestImage, level, branchcode, registration, channel, left, right, top, bottom, width, height, context);
    }

    ::std::function<void()>
    requestImageAsync(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, int left, int right, int top, int bottom, int width, int height,
                      ::std::function<void(::MDScallMPSService::ImageData)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MDScallMPSService::ImageData>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requestImage, level, branchcode, registration, channel, left, right, top, bottom, width, height, context);
    }

    /// \cond INTERNAL
    void _iceI_requestImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MDScallMPSService::ImageData>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, int, int, int, int, int, int, const ::Ice::Context&);
    /// \endcond

    void requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RegisterServicePrx::_iceI_requestTaskList, day, branchcode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requestTaskListAsync(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RegisterServicePrx::_iceI_requestTaskList, day, branchcode, context);
    }

    ::std::function<void()>
    requestTaskListAsync(const ::std::string& day, const ::std::string& branchcode,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requestTaskList, day, branchcode, context);
    }

    /// \cond INTERNAL
    void _iceI_requestTaskList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ::std::string requestSysOperPara(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &RegisterServicePrx::_iceI_requestSysOperPara, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requestSysOperParaAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &RegisterServicePrx::_iceI_requestSysOperPara, context);
    }

    ::std::function<void()>
    requestSysOperParaAsync(::std::function<void(::std::string)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requestSysOperPara, context);
    }

    /// \cond INTERNAL
    void _iceI_requestSysOperPara(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    ::std::string requsetSatPlatPara(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &RegisterServicePrx::_iceI_requsetSatPlatPara, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requsetSatPlatParaAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &RegisterServicePrx::_iceI_requsetSatPlatPara, context);
    }

    ::std::function<void()>
    requsetSatPlatParaAsync(::std::function<void(::std::string)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requsetSatPlatPara, context);
    }

    /// \cond INTERNAL
    void _iceI_requsetSatPlatPara(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    ImageData requsetYaoCe(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData>(true, this, &RegisterServicePrx::_iceI_requsetYaoCe, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requsetYaoCeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MDScallMPSService::ImageData>>().get_future())
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData, P>(false, this, &RegisterServicePrx::_iceI_requsetYaoCe, context);
    }

    ::std::function<void()>
    requsetYaoCeAsync(::std::function<void(::MDScallMPSService::ImageData)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MDScallMPSService::ImageData>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requsetYaoCe, context);
    }

    /// \cond INTERNAL
    void _iceI_requsetYaoCe(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MDScallMPSService::ImageData>>&, const ::Ice::Context&);
    /// \endcond

    ::std::string requestOrbitData(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &RegisterServicePrx::_iceI_requestOrbitData, time, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requestOrbitDataAsync(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &RegisterServicePrx::_iceI_requestOrbitData, time, context);
    }

    ::std::function<void()>
    requestOrbitDataAsync(const ::std::string& time,
                          ::std::function<void(::std::string)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requestOrbitData, time, context);
    }

    /// \cond INTERNAL
    void _iceI_requestOrbitData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ImageData getFile(const ::std::string& filename, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData>(true, this, &RegisterServicePrx::_iceI_getFile, filename, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getFileAsync(const ::std::string& filename, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MDScallMPSService::ImageData>>().get_future())
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData, P>(false, this, &RegisterServicePrx::_iceI_getFile, filename, context);
    }

    ::std::function<void()>
    getFileAsync(const ::std::string& filename,
                 ::std::function<void(::MDScallMPSService::ImageData)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MDScallMPSService::ImageData>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_getFile, filename, context);
    }

    /// \cond INTERNAL
    void _iceI_getFile(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MDScallMPSService::ImageData>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    XYZDATA requestxyzData(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MDScallMPSService::XYZDATA>(true, this, &RegisterServicePrx::_iceI_requestxyzData, time, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requestxyzDataAsync(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MDScallMPSService::XYZDATA>>().get_future())
    {
        return _makePromiseOutgoing<::MDScallMPSService::XYZDATA, P>(false, this, &RegisterServicePrx::_iceI_requestxyzData, time, context);
    }

    ::std::function<void()>
    requestxyzDataAsync(const ::std::string& time,
                        ::std::function<void(::MDScallMPSService::XYZDATA)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MDScallMPSService::XYZDATA>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requestxyzData, time, context);
    }

    /// \cond INTERNAL
    void _iceI_requestxyzData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MDScallMPSService::XYZDATA>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    RegisterServicePrx() = default;
    friend ::std::shared_ptr<RegisterServicePrx> IceInternal::createProxy<RegisterServicePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

namespace MPScallMDSService
{

class MDSServicePrx : public virtual ::Ice::Proxy<MDSServicePrx, ::Ice::ObjectPrx>
{
public:

    void pushUtcTime(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushUtcTime, time, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushUtcTimeAsync(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushUtcTime, time, context);
    }

    ::std::function<void()>
    pushUtcTimeAsync(const ::std::string& time,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushUtcTime, time, context);
    }

    /// \cond INTERNAL
    void _iceI_pushUtcTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void pushSysOperPara(const SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushSysOperPara, para, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushSysOperParaAsync(const SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushSysOperPara, para, context);
    }

    ::std::function<void()>
    pushSysOperParaAsync(const SysOperPara& para,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushSysOperPara, para, context);
    }

    /// \cond INTERNAL
    void _iceI_pushSysOperPara(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const SysOperPara&, const ::Ice::Context&);
    /// \endcond

    void pushSatPlatPara(const SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushSatPlatPara, para, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushSatPlatParaAsync(const SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushSatPlatPara, para, context);
    }

    ::std::function<void()>
    pushSatPlatParaAsync(const SatPlatPara& para,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushSatPlatPara, para, context);
    }

    /// \cond INTERNAL
    void _iceI_pushSatPlatPara(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const SatPlatPara&, const ::Ice::Context&);
    /// \endcond

    void pushTaskInfo(const ::std::string& branchCode, const TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushTaskInfo, branchCode, tasks, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushTaskInfoAsync(const ::std::string& branchCode, const TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushTaskInfo, branchCode, tasks, context);
    }

    ::std::function<void()>
    pushTaskInfoAsync(const ::std::string& branchCode, const TasksData& tasks,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushTaskInfo, branchCode, tasks, context);
    }

    /// \cond INTERNAL
    void _iceI_pushTaskInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const TasksData&, const ::Ice::Context&);
    /// \endcond

    void imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_imageReady, type, branch, Registration, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto imageReadyAsync(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_imageReady, type, branch, Registration, context);
    }

    ::std::function<void()>
    imageReadyAsync(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_imageReady, type, branch, Registration, context);
    }

    /// \cond INTERNAL
    void _iceI_imageReady(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void pushErrorLog(const ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushErrorLog, log, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushErrorLogAsync(const ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushErrorLog, log, context);
    }

    ::std::function<void()>
    pushErrorLogAsync(const ErrorLog& log,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushErrorLog, log, context);
    }

    /// \cond INTERNAL
    void _iceI_pushErrorLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ErrorLog&, const ::Ice::Context&);
    /// \endcond

    void pushTaskStatus(const TaskStatus& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushTaskStatus, status, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushTaskStatusAsync(const TaskStatus& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushTaskStatus, status, context);
    }

    ::std::function<void()>
    pushTaskStatusAsync(const TaskStatus& status,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushTaskStatus, status, context);
    }

    /// \cond INTERNAL
    void _iceI_pushTaskStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const TaskStatus&, const ::Ice::Context&);
    /// \endcond

    void pushOrbitData(const OrbitData& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushOrbitData, data, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushOrbitDataAsync(const OrbitData& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushOrbitData, data, context);
    }

    ::std::function<void()>
    pushOrbitDataAsync(const OrbitData& data,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushOrbitData, data, context);
    }

    /// \cond INTERNAL
    void _iceI_pushOrbitData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const OrbitData&, const ::Ice::Context&);
    /// \endcond

    void pushFFTData(const FFTDATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushFFTData, data, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushFFTDataAsync(const FFTDATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushFFTData, data, context);
    }

    ::std::function<void()>
    pushFFTDataAsync(const FFTDATA& data,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushFFTData, data, context);
    }

    /// \cond INTERNAL
    void _iceI_pushFFTData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const FFTDATA&, const ::Ice::Context&);
    /// \endcond

    void pushPQAData(const PQADATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushPQAData, data, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushPQADataAsync(const PQADATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushPQAData, data, context);
    }

    ::std::function<void()>
    pushPQADataAsync(const PQADATA& data,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushPQAData, data, context);
    }

    /// \cond INTERNAL
    void _iceI_pushPQAData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const PQADATA&, const ::Ice::Context&);
    /// \endcond

    void pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushTime, type, branchCode, time, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushTimeAsync(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushTime, type, branchCode, time, context);
    }

    ::std::function<void()>
    pushTimeAsync(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushTime, type, branchCode, time, context);
    }

    /// \cond INTERNAL
    void _iceI_pushTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void pushSysLog(const SysLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushSysLog, log, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushSysLogAsync(const SysLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushSysLog, log, context);
    }

    ::std::function<void()>
    pushSysLogAsync(const SysLog& log,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushSysLog, log, context);
    }

    /// \cond INTERNAL
    void _iceI_pushSysLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const SysLog&, const ::Ice::Context&);
    /// \endcond

    void pushInstruction(const Instruction& ins, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushInstruction, ins, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushInstructionAsync(const Instruction& ins, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushInstruction, ins, context);
    }

    ::std::function<void()>
    pushInstructionAsync(const Instruction& ins,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushInstruction, ins, context);
    }

    /// \cond INTERNAL
    void _iceI_pushInstruction(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Instruction&, const ::Ice::Context&);
    /// \endcond

    void pushYaoceyaokongsuju(const Yaoceyaokongsuju& yaoce, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushYaoceyaokongsuju, yaoce, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushYaoceyaokongsujuAsync(const Yaoceyaokongsuju& yaoce, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushYaoceyaokongsuju, yaoce, context);
    }

    ::std::function<void()>
    pushYaoceyaokongsujuAsync(const Yaoceyaokongsuju& yaoce,
                              ::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushYaoceyaokongsuju, yaoce, context);
    }

    /// \cond INTERNAL
    void _iceI_pushYaoceyaokongsuju(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Yaoceyaokongsuju&, const ::Ice::Context&);
    /// \endcond

    void pushProgressAnalysis(const ProgressAnalysis& pa, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushProgressAnalysis, pa, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushProgressAnalysisAsync(const ProgressAnalysis& pa, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushProgressAnalysis, pa, context);
    }

    ::std::function<void()>
    pushProgressAnalysisAsync(const ProgressAnalysis& pa,
                              ::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushProgressAnalysis, pa, context);
    }

    /// \cond INTERNAL
    void _iceI_pushProgressAnalysis(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ProgressAnalysis&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MDSServicePrx() = default;
    friend ::std::shared_ptr<MDSServicePrx> IceInternal::createProxy<MDSServicePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::MDScallMPSService::XYZDATA>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MDScallMPSService::XYZDATA, S>
{
    static void read(S* istr, ::MDScallMPSService::XYZDATA& v)
    {
        istr->readAll(v.x, v.y, v.z);
    }
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::MPScallMDSService::SysOperPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 44;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::SysOperPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SysOperPara& v)
    {
        istr->readAll(v.ParamType, v.SatID, v.GIIRSTeleCmdTime, v.GIIRSTeleCmdPushCycle, v.AGRITeleCmdPushCycle, v.AGRITeleCmdTime, v.RSITeleCmdPushCycle, v.RSITeleCmdTime, v.GIIRSAMC, v.GIIRSOMC, v.AGRITMC, v.RSIINRFLOW, v.GRIISINRFLOW, v.AGRIAMC, v.AGRIOMC, v.AGRIXINRFLOW, v.GIIRSTMC, v.RSIAMC, v.RSIOMC, v.RSITMC, v.GIIRSNRS, v.AGRINRS, v.RSINRS);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::SatPlatPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 42;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::SatPlatPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SatPlatPara& v)
    {
        istr->readAll(v.ParamType, v.SatID, v.GIIRSTmcTranCh, v.AGRITmcTranCh, v.FlutterTranCh, v.INRDataTranCh, v.SatSenserTranCh, v.FixedPosRegTranCh, v.SEPDataTranCh, v.RSIDataTranCh, v.AGRIDataTranCh, v.GIIRSProDataTranCh, v.GIIRSRawDataTranCh, v.DataTranRightCh, v.DataTranLeftCh, v.OrbitConWorkSta, v.ImagePositionSta, v.SatColScreenFace, v.NorOrbAngleRange, v.FGMWorkStatus, v.RADDWorkStatus, v.HEPDWorkStatus, v.CPDWorkStatus, v.RSIWorkStatus, v.GIIRSWorkStatus, v.AGRIWorkStatus, v.SatWorkStatus, v.OrbitLocation, v.RSITmcTranCh);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::Task>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::Task, S>
{
    static void read(S* istr, ::MPScallMDSService::Task& v)
    {
        istr->readAll(v.TaskEN, v.TaskCN, v.TaskCode, v.Exdate, v.StartTime, v.EndTime, v.ExStatus, v.RealStartTime, v.RealEndTime);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::ErrorLog>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::ErrorLog, S>
{
    static void read(S* istr, ::MPScallMDSService::ErrorLog& v)
    {
        istr->readAll(v.branchcode, v.errorlevel, v.status, v.time, v.taskcode, v.message, v.errorcode);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::TaskStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::TaskStatus, S>
{
    static void read(S* istr, ::MPScallMDSService::TaskStatus& v)
    {
        istr->readAll(v.branchcode, v.taskcode, v.status, v.dealtag, v.time);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::OrbitData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::OrbitData, S>
{
    static void read(S* istr, ::MPScallMDSService::OrbitData& v)
    {
        istr->readAll(v.x, v.y, v.z);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::FFTDATA>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::MPScallMDSService::FFTDATA, S>
{
    static void read(S* istr, ::MPScallMDSService::FFTDATA& v)
    {
        istr->readAll(v.rolling, v.pitch, v.yaw, v.dipAngle);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::PQADATA>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::PQADATA, S>
{
    static void read(S* istr, ::MPScallMDSService::PQADATA& v)
    {
        istr->readAll(v.branch, v.taskcode, v.time, v.Band1, v.Band2, v.Band3, v.Band4, v.Band5, v.Band6, v.Band7, v.Band8, v.Band9, v.Band10, v.Band11, v.Band12, v.Band13, v.Band14, v.Band15, v.Band16);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::SysLog>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::SysLog, S>
{
    static void read(S* istr, ::MPScallMDSService::SysLog& v)
    {
        istr->readAll(v.branchcode, v.logattri, v.time, v.taskcode, v.message);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::Instruction>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::Instruction, S>
{
    static void read(S* istr, ::MPScallMDSService::Instruction& v)
    {
        istr->readAll(v.type, v.satcode, v.scheduletype, v.modifytime, v.dealtime, v.status, v.desc);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::Yaoceyaokongsuju>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::Yaoceyaokongsuju, S>
{
    static void read(S* istr, ::MPScallMDSService::Yaoceyaokongsuju& v)
    {
        istr->readAll(v.FLCX, v.XXD, v.SDNX, v.ZTDNX, v.XMa, v.XMb, v.XMc, v.FFTC, v.AGRIXBC, v.GRRISBC, v.GHIBC, v.AGRIXTMC, v.AGRIXOMC, v.AGRIXAMC, v.GRRISTMC, v.GRRISOMC, v.GRRISAMC, v.GHITMC, v.GHIOMC, v.GHIAMC);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::ProgressAnalysis>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::ProgressAnalysis, S>
{
    static void read(S* istr, ::MPScallMDSService::ProgressAnalysis& v)
    {
        istr->readAll(v.taskCode, v.branchCode, v.type, v.current, v.total);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::ProgressAllAnalysis>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::ProgressAllAnalysis, S>
{
    static void read(S* istr, ::MPScallMDSService::ProgressAllAnalysis& v)
    {
        istr->readAll(v.taskCode, v.branchCode, v.dwCurrent, v.ccyCurrent, v.l1aCurrent, v.total);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::BandRegData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::BandRegData, S>
{
    static void read(S* istr, ::MPScallMDSService::BandRegData& v)
    {
        istr->readAll(v.taskCode, v.branchCode, v.bandReg);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::TaskTime>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::TaskTime, S>
{
    static void read(S* istr, ::MPScallMDSService::TaskTime& v)
    {
        istr->readAll(v.id, v.taskcode, v.exdate, v.l0receivedate, v.l1acompletedate, v.branchcode);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::ErrlrCount>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::MPScallMDSService::ErrlrCount, S>
{
    static void read(S* istr, ::MPScallMDSService::ErrlrCount& v)
    {
        istr->readAll(v.level1, v.level2, v.level3);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace MDScallMPSService
{

using LoginServiceProxyPtr = ::std::shared_ptr<LoginServiceProxy>;
using LoginServiceProxyPrxPtr = ::std::shared_ptr<LoginServiceProxyPrx>;

using RegisterServicePtr = ::std::shared_ptr<RegisterService>;
using RegisterServicePrxPtr = ::std::shared_ptr<RegisterServicePrx>;

}
/// \endcond

/// \cond INTERNAL
namespace MPScallMDSService
{

using MDSServicePtr = ::std::shared_ptr<MDSService>;
using MDSServicePrxPtr = ::std::shared_ptr<MDSServicePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace MDScallMPSService
{

class LoginServiceProxy;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LoginServiceProxy>&);
::IceProxy::Ice::Object* upCast(LoginServiceProxy*);
/// \endcond

class RegisterService;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< RegisterService>&);
::IceProxy::Ice::Object* upCast(RegisterService*);
/// \endcond

}

namespace MPScallMDSService
{

class MDSService;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MDSService>&);
::IceProxy::Ice::Object* upCast(MDSService*);
/// \endcond

}

}

namespace MDScallMPSService
{

class LoginServiceProxy;
/// \cond INTERNAL
::Ice::Object* upCast(LoginServiceProxy*);
/// \endcond
typedef ::IceInternal::Handle< LoginServiceProxy> LoginServiceProxyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MDScallMPSService::LoginServiceProxy> LoginServiceProxyPrx;
typedef LoginServiceProxyPrx LoginServiceProxyPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LoginServiceProxyPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class RegisterService;
/// \cond INTERNAL
::Ice::Object* upCast(RegisterService*);
/// \endcond
typedef ::IceInternal::Handle< RegisterService> RegisterServicePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MDScallMPSService::RegisterService> RegisterServicePrx;
typedef RegisterServicePrx RegisterServicePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RegisterServicePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace MPScallMDSService
{

class MDSService;
/// \cond INTERNAL
::Ice::Object* upCast(MDSService*);
/// \endcond
typedef ::IceInternal::Handle< MDSService> MDSServicePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPScallMDSService::MDSService> MDSServicePrx;
typedef MDSServicePrx MDSServicePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MDSServicePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace MDScallMPSService
{

typedef ::std::vector< ::Ice::Byte> ImageData;

struct XYZDATA
{
    ::std::string x;
    ::std::string y;
    ::std::string z;

    bool operator==(const XYZDATA& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        if(z != rhs_.z)
        {
            return false;
        }
        return true;
    }

    bool operator<(const XYZDATA& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        if(z < rhs_.z)
        {
            return true;
        }
        else if(rhs_.z < z)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const XYZDATA& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const XYZDATA& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const XYZDATA& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const XYZDATA& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace MPScallMDSService
{

struct SysOperPara
{
    ::Ice::Int ParamType;
    ::std::string SatID;
    ::Ice::Int GIIRSTeleCmdTime;
    ::Ice::Int GIIRSTeleCmdPushCycle;
    ::Ice::Int AGRITeleCmdPushCycle;
    ::Ice::Int AGRITeleCmdTime;
    ::Ice::Int RSITeleCmdPushCycle;
    ::Ice::Int RSITeleCmdTime;
    ::Ice::Byte GIIRSAMC;
    ::Ice::Byte GIIRSOMC;
    ::Ice::Byte AGRITMC;
    ::Ice::Byte RSIINRFLOW;
    ::Ice::Byte GRIISINRFLOW;
    ::Ice::Byte AGRIAMC;
    ::Ice::Byte AGRIOMC;
    ::Ice::Byte AGRIXINRFLOW;
    ::Ice::Byte GIIRSTMC;
    ::Ice::Byte RSIAMC;
    ::Ice::Byte RSIOMC;
    ::Ice::Byte RSITMC;
    ::Ice::Byte GIIRSNRS;
    ::Ice::Byte AGRINRS;
    ::Ice::Byte RSINRS;

    bool operator==(const SysOperPara& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(ParamType != rhs_.ParamType)
        {
            return false;
        }
        if(SatID != rhs_.SatID)
        {
            return false;
        }
        if(GIIRSTeleCmdTime != rhs_.GIIRSTeleCmdTime)
        {
            return false;
        }
        if(GIIRSTeleCmdPushCycle != rhs_.GIIRSTeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdPushCycle != rhs_.AGRITeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdTime != rhs_.AGRITeleCmdTime)
        {
            return false;
        }
        if(RSITeleCmdPushCycle != rhs_.RSITeleCmdPushCycle)
        {
            return false;
        }
        if(RSITeleCmdTime != rhs_.RSITeleCmdTime)
        {
            return false;
        }
        if(GIIRSAMC != rhs_.GIIRSAMC)
        {
            return false;
        }
        if(GIIRSOMC != rhs_.GIIRSOMC)
        {
            return false;
        }
        if(AGRITMC != rhs_.AGRITMC)
        {
            return false;
        }
        if(RSIINRFLOW != rhs_.RSIINRFLOW)
        {
            return false;
        }
        if(GRIISINRFLOW != rhs_.GRIISINRFLOW)
        {
            return false;
        }
        if(AGRIAMC != rhs_.AGRIAMC)
        {
            return false;
        }
        if(AGRIOMC != rhs_.AGRIOMC)
        {
            return false;
        }
        if(AGRIXINRFLOW != rhs_.AGRIXINRFLOW)
        {
            return false;
        }
        if(GIIRSTMC != rhs_.GIIRSTMC)
        {
            return false;
        }
        if(RSIAMC != rhs_.RSIAMC)
        {
            return false;
        }
        if(RSIOMC != rhs_.RSIOMC)
        {
            return false;
        }
        if(RSITMC != rhs_.RSITMC)
        {
            return false;
        }
        if(GIIRSNRS != rhs_.GIIRSNRS)
        {
            return false;
        }
        if(AGRINRS != rhs_.AGRINRS)
        {
            return false;
        }
        if(RSINRS != rhs_.RSINRS)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SysOperPara& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(ParamType < rhs_.ParamType)
        {
            return true;
        }
        else if(rhs_.ParamType < ParamType)
        {
            return false;
        }
        if(SatID < rhs_.SatID)
        {
            return true;
        }
        else if(rhs_.SatID < SatID)
        {
            return false;
        }
        if(GIIRSTeleCmdTime < rhs_.GIIRSTeleCmdTime)
        {
            return true;
        }
        else if(rhs_.GIIRSTeleCmdTime < GIIRSTeleCmdTime)
        {
            return false;
        }
        if(GIIRSTeleCmdPushCycle < rhs_.GIIRSTeleCmdPushCycle)
        {
            return true;
        }
        else if(rhs_.GIIRSTeleCmdPushCycle < GIIRSTeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdPushCycle < rhs_.AGRITeleCmdPushCycle)
        {
            return true;
        }
        else if(rhs_.AGRITeleCmdPushCycle < AGRITeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdTime < rhs_.AGRITeleCmdTime)
        {
            return true;
        }
        else if(rhs_.AGRITeleCmdTime < AGRITeleCmdTime)
        {
            return false;
        }
        if(RSITeleCmdPushCycle < rhs_.RSITeleCmdPushCycle)
        {
            return true;
        }
        else if(rhs_.RSITeleCmdPushCycle < RSITeleCmdPushCycle)
        {
            return false;
        }
        if(RSITeleCmdTime < rhs_.RSITeleCmdTime)
        {
            return true;
        }
        else if(rhs_.RSITeleCmdTime < RSITeleCmdTime)
        {
            return false;
        }
        if(GIIRSAMC < rhs_.GIIRSAMC)
        {
            return true;
        }
        else if(rhs_.GIIRSAMC < GIIRSAMC)
        {
            return false;
        }
        if(GIIRSOMC < rhs_.GIIRSOMC)
        {
            return true;
        }
        else if(rhs_.GIIRSOMC < GIIRSOMC)
        {
            return false;
        }
        if(AGRITMC < rhs_.AGRITMC)
        {
            return true;
        }
        else if(rhs_.AGRITMC < AGRITMC)
        {
            return false;
        }
        if(RSIINRFLOW < rhs_.RSIINRFLOW)
        {
            return true;
        }
        else if(rhs_.RSIINRFLOW < RSIINRFLOW)
        {
            return false;
        }
        if(GRIISINRFLOW < rhs_.GRIISINRFLOW)
        {
            return true;
        }
        else if(rhs_.GRIISINRFLOW < GRIISINRFLOW)
        {
            return false;
        }
        if(AGRIAMC < rhs_.AGRIAMC)
        {
            return true;
        }
        else if(rhs_.AGRIAMC < AGRIAMC)
        {
            return false;
        }
        if(AGRIOMC < rhs_.AGRIOMC)
        {
            return true;
        }
        else if(rhs_.AGRIOMC < AGRIOMC)
        {
            return false;
        }
        if(AGRIXINRFLOW < rhs_.AGRIXINRFLOW)
        {
            return true;
        }
        else if(rhs_.AGRIXINRFLOW < AGRIXINRFLOW)
        {
            return false;
        }
        if(GIIRSTMC < rhs_.GIIRSTMC)
        {
            return true;
        }
        else if(rhs_.GIIRSTMC < GIIRSTMC)
        {
            return false;
        }
        if(RSIAMC < rhs_.RSIAMC)
        {
            return true;
        }
        else if(rhs_.RSIAMC < RSIAMC)
        {
            return false;
        }
        if(RSIOMC < rhs_.RSIOMC)
        {
            return true;
        }
        else if(rhs_.RSIOMC < RSIOMC)
        {
            return false;
        }
        if(RSITMC < rhs_.RSITMC)
        {
            return true;
        }
        else if(rhs_.RSITMC < RSITMC)
        {
            return false;
        }
        if(GIIRSNRS < rhs_.GIIRSNRS)
        {
            return true;
        }
        else if(rhs_.GIIRSNRS < GIIRSNRS)
        {
            return false;
        }
        if(AGRINRS < rhs_.AGRINRS)
        {
            return true;
        }
        else if(rhs_.AGRINRS < AGRINRS)
        {
            return false;
        }
        if(RSINRS < rhs_.RSINRS)
        {
            return true;
        }
        else if(rhs_.RSINRS < RSINRS)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SysOperPara& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SysOperPara& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SysOperPara& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SysOperPara& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct SatPlatPara
{
    ::Ice::Int ParamType;
    ::std::string SatID;
    ::std::string GIIRSTmcTranCh;
    ::std::string AGRITmcTranCh;
    ::std::string FlutterTranCh;
    ::std::string INRDataTranCh;
    ::std::string SatSenserTranCh;
    ::std::string FixedPosRegTranCh;
    ::std::string SEPDataTranCh;
    ::std::string RSIDataTranCh;
    ::std::string AGRIDataTranCh;
    ::std::string GIIRSProDataTranCh;
    ::std::string GIIRSRawDataTranCh;
    ::std::string DataTranRightCh;
    ::std::string DataTranLeftCh;
    ::std::string OrbitConWorkSta;
    ::std::string ImagePositionSta;
    ::std::string SatColScreenFace;
    ::Ice::Int NorOrbAngleRange;
    ::std::string FGMWorkStatus;
    ::std::string RADDWorkStatus;
    ::std::string HEPDWorkStatus;
    ::std::string CPDWorkStatus;
    ::std::string RSIWorkStatus;
    ::std::string GIIRSWorkStatus;
    ::std::string AGRIWorkStatus;
    ::std::string SatWorkStatus;
    ::Ice::Double OrbitLocation;
    ::std::string RSITmcTranCh;
};

struct Task
{
    ::std::string TaskEN;
    ::std::string TaskCN;
    ::std::string TaskCode;
    ::std::string Exdate;
    ::std::string StartTime;
    ::std::string EndTime;
    ::std::string ExStatus;
    ::std::string RealStartTime;
    ::std::string RealEndTime;

    bool operator==(const Task& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(TaskEN != rhs_.TaskEN)
        {
            return false;
        }
        if(TaskCN != rhs_.TaskCN)
        {
            return false;
        }
        if(TaskCode != rhs_.TaskCode)
        {
            return false;
        }
        if(Exdate != rhs_.Exdate)
        {
            return false;
        }
        if(StartTime != rhs_.StartTime)
        {
            return false;
        }
        if(EndTime != rhs_.EndTime)
        {
            return false;
        }
        if(ExStatus != rhs_.ExStatus)
        {
            return false;
        }
        if(RealStartTime != rhs_.RealStartTime)
        {
            return false;
        }
        if(RealEndTime != rhs_.RealEndTime)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Task& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(TaskEN < rhs_.TaskEN)
        {
            return true;
        }
        else if(rhs_.TaskEN < TaskEN)
        {
            return false;
        }
        if(TaskCN < rhs_.TaskCN)
        {
            return true;
        }
        else if(rhs_.TaskCN < TaskCN)
        {
            return false;
        }
        if(TaskCode < rhs_.TaskCode)
        {
            return true;
        }
        else if(rhs_.TaskCode < TaskCode)
        {
            return false;
        }
        if(Exdate < rhs_.Exdate)
        {
            return true;
        }
        else if(rhs_.Exdate < Exdate)
        {
            return false;
        }
        if(StartTime < rhs_.StartTime)
        {
            return true;
        }
        else if(rhs_.StartTime < StartTime)
        {
            return false;
        }
        if(EndTime < rhs_.EndTime)
        {
            return true;
        }
        else if(rhs_.EndTime < EndTime)
        {
            return false;
        }
        if(ExStatus < rhs_.ExStatus)
        {
            return true;
        }
        else if(rhs_.ExStatus < ExStatus)
        {
            return false;
        }
        if(RealStartTime < rhs_.RealStartTime)
        {
            return true;
        }
        else if(rhs_.RealStartTime < RealStartTime)
        {
            return false;
        }
        if(RealEndTime < rhs_.RealEndTime)
        {
            return true;
        }
        else if(rhs_.RealEndTime < RealEndTime)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Task& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Task& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Task& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Task& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Task> TasksData;

typedef ::std::vector< ::Ice::Byte> ImageData;

struct ErrorLog
{
    ::std::string branchcode;
    ::std::string errorlevel;
    ::std::string status;
    ::std::string time;
    ::std::string taskcode;
    ::std::string message;
    ::std::string errorcode;

    bool operator==(const ErrorLog& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(branchcode != rhs_.branchcode)
        {
            return false;
        }
        if(errorlevel != rhs_.errorlevel)
        {
            return false;
        }
        if(status != rhs_.status)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(taskcode != rhs_.taskcode)
        {
            return false;
        }
        if(message != rhs_.message)
        {
            return false;
        }
        if(errorcode != rhs_.errorcode)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ErrorLog& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(branchcode < rhs_.branchcode)
        {
            return true;
        }
        else if(rhs_.branchcode < branchcode)
        {
            return false;
        }
        if(errorlevel < rhs_.errorlevel)
        {
            return true;
        }
        else if(rhs_.errorlevel < errorlevel)
        {
            return false;
        }
        if(status < rhs_.status)
        {
            return true;
        }
        else if(rhs_.status < status)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(taskcode < rhs_.taskcode)
        {
            return true;
        }
        else if(rhs_.taskcode < taskcode)
        {
            return false;
        }
        if(message < rhs_.message)
        {
            return true;
        }
        else if(rhs_.message < message)
        {
            return false;
        }
        if(errorcode < rhs_.errorcode)
        {
            return true;
        }
        else if(rhs_.errorcode < errorcode)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ErrorLog& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ErrorLog& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ErrorLog& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ErrorLog& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct TaskStatus
{
    ::std::string branchcode;
    ::std::string taskcode;
    ::Ice::Int status;
    ::std::string dealtag;
    ::std::string time;

    bool operator==(const TaskStatus& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(branchcode != rhs_.branchcode)
        {
            return false;
        }
        if(taskcode != rhs_.taskcode)
        {
            return false;
        }
        if(status != rhs_.status)
        {
            return false;
        }
        if(dealtag != rhs_.dealtag)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TaskStatus& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(branchcode < rhs_.branchcode)
        {
            return true;
        }
        else if(rhs_.branchcode < branchcode)
        {
            return false;
        }
        if(taskcode < rhs_.taskcode)
        {
            return true;
        }
        else if(rhs_.taskcode < taskcode)
        {
            return false;
        }
        if(status < rhs_.status)
        {
            return true;
        }
        else if(rhs_.status < status)
        {
            return false;
        }
        if(dealtag < rhs_.dealtag)
        {
            return true;
        }
        else if(rhs_.dealtag < dealtag)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TaskStatus& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const TaskStatus& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const TaskStatus& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const TaskStatus& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct OrbitData
{
    ::std::string x;
    ::std::string y;
    ::std::string z;

    bool operator==(const OrbitData& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        if(z != rhs_.z)
        {
            return false;
        }
        return true;
    }

    bool operator<(const OrbitData& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        if(z < rhs_.z)
        {
            return true;
        }
        else if(rhs_.z < z)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const OrbitData& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const OrbitData& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const OrbitData& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const OrbitData& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct FFTDATA
{
    ::Ice::Float rolling;
    ::Ice::Float pitch;
    ::Ice::Float yaw;
    ::Ice::Float dipAngle;
};

struct PQADATA
{
    ::std::string branch;
    ::std::string taskcode;
    ::std::string time;
    ::std::string Band1;
    ::std::string Band2;
    ::std::string Band3;
    ::std::string Band4;
    ::std::string Band5;
    ::std::string Band6;
    ::std::string Band7;
    ::std::string Band8;
    ::std::string Band9;
    ::std::string Band10;
    ::std::string Band11;
    ::std::string Band12;
    ::std::string Band13;
    ::std::string Band14;
    ::std::string Band15;
    ::std::string Band16;

    bool operator==(const PQADATA& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(branch != rhs_.branch)
        {
            return false;
        }
        if(taskcode != rhs_.taskcode)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(Band1 != rhs_.Band1)
        {
            return false;
        }
        if(Band2 != rhs_.Band2)
        {
            return false;
        }
        if(Band3 != rhs_.Band3)
        {
            return false;
        }
        if(Band4 != rhs_.Band4)
        {
            return false;
        }
        if(Band5 != rhs_.Band5)
        {
            return false;
        }
        if(Band6 != rhs_.Band6)
        {
            return false;
        }
        if(Band7 != rhs_.Band7)
        {
            return false;
        }
        if(Band8 != rhs_.Band8)
        {
            return false;
        }
        if(Band9 != rhs_.Band9)
        {
            return false;
        }
        if(Band10 != rhs_.Band10)
        {
            return false;
        }
        if(Band11 != rhs_.Band11)
        {
            return false;
        }
        if(Band12 != rhs_.Band12)
        {
            return false;
        }
        if(Band13 != rhs_.Band13)
        {
            return false;
        }
        if(Band14 != rhs_.Band14)
        {
            return false;
        }
        if(Band15 != rhs_.Band15)
        {
            return false;
        }
        if(Band16 != rhs_.Band16)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PQADATA& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(branch < rhs_.branch)
        {
            return true;
        }
        else if(rhs_.branch < branch)
        {
            return false;
        }
        if(taskcode < rhs_.taskcode)
        {
            return true;
        }
        else if(rhs_.taskcode < taskcode)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(Band1 < rhs_.Band1)
        {
            return true;
        }
        else if(rhs_.Band1 < Band1)
        {
            return false;
        }
        if(Band2 < rhs_.Band2)
        {
            return true;
        }
        else if(rhs_.Band2 < Band2)
        {
            return false;
        }
        if(Band3 < rhs_.Band3)
        {
            return true;
        }
        else if(rhs_.Band3 < Band3)
        {
            return false;
        }
        if(Band4 < rhs_.Band4)
        {
            return true;
        }
        else if(rhs_.Band4 < Band4)
        {
            return false;
        }
        if(Band5 < rhs_.Band5)
        {
            return true;
        }
        else if(rhs_.Band5 < Band5)
        {
            return false;
        }
        if(Band6 < rhs_.Band6)
        {
            return true;
        }
        else if(rhs_.Band6 < Band6)
        {
            return false;
        }
        if(Band7 < rhs_.Band7)
        {
            return true;
        }
        else if(rhs_.Band7 < Band7)
        {
            return false;
        }
        if(Band8 < rhs_.Band8)
        {
            return true;
        }
        else if(rhs_.Band8 < Band8)
        {
            return false;
        }
        if(Band9 < rhs_.Band9)
        {
            return true;
        }
        else if(rhs_.Band9 < Band9)
        {
            return false;
        }
        if(Band10 < rhs_.Band10)
        {
            return true;
        }
        else if(rhs_.Band10 < Band10)
        {
            return false;
        }
        if(Band11 < rhs_.Band11)
        {
            return true;
        }
        else if(rhs_.Band11 < Band11)
        {
            return false;
        }
        if(Band12 < rhs_.Band12)
        {
            return true;
        }
        else if(rhs_.Band12 < Band12)
        {
            return false;
        }
        if(Band13 < rhs_.Band13)
        {
            return true;
        }
        else if(rhs_.Band13 < Band13)
        {
            return false;
        }
        if(Band14 < rhs_.Band14)
        {
            return true;
        }
        else if(rhs_.Band14 < Band14)
        {
            return false;
        }
        if(Band15 < rhs_.Band15)
        {
            return true;
        }
        else if(rhs_.Band15 < Band15)
        {
            return false;
        }
        if(Band16 < rhs_.Band16)
        {
            return true;
        }
        else if(rhs_.Band16 < Band16)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PQADATA& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const PQADATA& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const PQADATA& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const PQADATA& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct SysLog
{
    ::std::string branchcode;
    ::std::string logattri;
    ::std::string time;
    ::std::string taskcode;
    ::std::string message;

    bool operator==(const SysLog& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(branchcode != rhs_.branchcode)
        {
            return false;
        }
        if(logattri != rhs_.logattri)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(taskcode != rhs_.taskcode)
        {
            return false;
        }
        if(message != rhs_.message)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SysLog& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(branchcode < rhs_.branchcode)
        {
            return true;
        }
        else if(rhs_.branchcode < branchcode)
        {
            return false;
        }
        if(logattri < rhs_.logattri)
        {
            return true;
        }
        else if(rhs_.logattri < logattri)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(taskcode < rhs_.taskcode)
        {
            return true;
        }
        else if(rhs_.taskcode < taskcode)
        {
            return false;
        }
        if(message < rhs_.message)
        {
            return true;
        }
        else if(rhs_.message < message)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SysLog& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SysLog& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SysLog& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SysLog& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Instruction
{
    ::std::string type;
    ::std::string satcode;
    ::std::string scheduletype;
    ::std::string modifytime;
    ::std::string dealtime;
    ::std::string status;
    ::std::string desc;

    bool operator==(const Instruction& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(type != rhs_.type)
        {
            return false;
        }
        if(satcode != rhs_.satcode)
        {
            return false;
        }
        if(scheduletype != rhs_.scheduletype)
        {
            return false;
        }
        if(modifytime != rhs_.modifytime)
        {
            return false;
        }
        if(dealtime != rhs_.dealtime)
        {
            return false;
        }
        if(status != rhs_.status)
        {
            return false;
        }
        if(desc != rhs_.desc)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Instruction& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(type < rhs_.type)
        {
            return true;
        }
        else if(rhs_.type < type)
        {
            return false;
        }
        if(satcode < rhs_.satcode)
        {
            return true;
        }
        else if(rhs_.satcode < satcode)
        {
            return false;
        }
        if(scheduletype < rhs_.scheduletype)
        {
            return true;
        }
        else if(rhs_.scheduletype < scheduletype)
        {
            return false;
        }
        if(modifytime < rhs_.modifytime)
        {
            return true;
        }
        else if(rhs_.modifytime < modifytime)
        {
            return false;
        }
        if(dealtime < rhs_.dealtime)
        {
            return true;
        }
        else if(rhs_.dealtime < dealtime)
        {
            return false;
        }
        if(status < rhs_.status)
        {
            return true;
        }
        else if(rhs_.status < status)
        {
            return false;
        }
        if(desc < rhs_.desc)
        {
            return true;
        }
        else if(rhs_.desc < desc)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Instruction& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Instruction& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Instruction& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Instruction& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Yaoceyaokongsuju
{
    ::std::string FLCX;
    ::std::string XXD;
    ::std::string SDNX;
    ::std::string ZTDNX;
    ::std::string XMa;
    ::std::string XMb;
    ::std::string XMc;
    ::std::string FFTC;
    ::std::string AGRIXBC;
    ::std::string GRRISBC;
    ::std::string GHIBC;
    ::std::string AGRIXTMC;
    ::std::string AGRIXOMC;
    ::std::string AGRIXAMC;
    ::std::string GRRISTMC;
    ::std::string GRRISOMC;
    ::std::string GRRISAMC;
    ::std::string GHITMC;
    ::std::string GHIOMC;
    ::std::string GHIAMC;

    bool operator==(const Yaoceyaokongsuju& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(FLCX != rhs_.FLCX)
        {
            return false;
        }
        if(XXD != rhs_.XXD)
        {
            return false;
        }
        if(SDNX != rhs_.SDNX)
        {
            return false;
        }
        if(ZTDNX != rhs_.ZTDNX)
        {
            return false;
        }
        if(XMa != rhs_.XMa)
        {
            return false;
        }
        if(XMb != rhs_.XMb)
        {
            return false;
        }
        if(XMc != rhs_.XMc)
        {
            return false;
        }
        if(FFTC != rhs_.FFTC)
        {
            return false;
        }
        if(AGRIXBC != rhs_.AGRIXBC)
        {
            return false;
        }
        if(GRRISBC != rhs_.GRRISBC)
        {
            return false;
        }
        if(GHIBC != rhs_.GHIBC)
        {
            return false;
        }
        if(AGRIXTMC != rhs_.AGRIXTMC)
        {
            return false;
        }
        if(AGRIXOMC != rhs_.AGRIXOMC)
        {
            return false;
        }
        if(AGRIXAMC != rhs_.AGRIXAMC)
        {
            return false;
        }
        if(GRRISTMC != rhs_.GRRISTMC)
        {
            return false;
        }
        if(GRRISOMC != rhs_.GRRISOMC)
        {
            return false;
        }
        if(GRRISAMC != rhs_.GRRISAMC)
        {
            return false;
        }
        if(GHITMC != rhs_.GHITMC)
        {
            return false;
        }
        if(GHIOMC != rhs_.GHIOMC)
        {
            return false;
        }
        if(GHIAMC != rhs_.GHIAMC)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Yaoceyaokongsuju& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(FLCX < rhs_.FLCX)
        {
            return true;
        }
        else if(rhs_.FLCX < FLCX)
        {
            return false;
        }
        if(XXD < rhs_.XXD)
        {
            return true;
        }
        else if(rhs_.XXD < XXD)
        {
            return false;
        }
        if(SDNX < rhs_.SDNX)
        {
            return true;
        }
        else if(rhs_.SDNX < SDNX)
        {
            return false;
        }
        if(ZTDNX < rhs_.ZTDNX)
        {
            return true;
        }
        else if(rhs_.ZTDNX < ZTDNX)
        {
            return false;
        }
        if(XMa < rhs_.XMa)
        {
            return true;
        }
        else if(rhs_.XMa < XMa)
        {
            return false;
        }
        if(XMb < rhs_.XMb)
        {
            return true;
        }
        else if(rhs_.XMb < XMb)
        {
            return false;
        }
        if(XMc < rhs_.XMc)
        {
            return true;
        }
        else if(rhs_.XMc < XMc)
        {
            return false;
        }
        if(FFTC < rhs_.FFTC)
        {
            return true;
        }
        else if(rhs_.FFTC < FFTC)
        {
            return false;
        }
        if(AGRIXBC < rhs_.AGRIXBC)
        {
            return true;
        }
        else if(rhs_.AGRIXBC < AGRIXBC)
        {
            return false;
        }
        if(GRRISBC < rhs_.GRRISBC)
        {
            return true;
        }
        else if(rhs_.GRRISBC < GRRISBC)
        {
            return false;
        }
        if(GHIBC < rhs_.GHIBC)
        {
            return true;
        }
        else if(rhs_.GHIBC < GHIBC)
        {
            return false;
        }
        if(AGRIXTMC < rhs_.AGRIXTMC)
        {
            return true;
        }
        else if(rhs_.AGRIXTMC < AGRIXTMC)
        {
            return false;
        }
        if(AGRIXOMC < rhs_.AGRIXOMC)
        {
            return true;
        }
        else if(rhs_.AGRIXOMC < AGRIXOMC)
        {
            return false;
        }
        if(AGRIXAMC < rhs_.AGRIXAMC)
        {
            return true;
        }
        else if(rhs_.AGRIXAMC < AGRIXAMC)
        {
            return false;
        }
        if(GRRISTMC < rhs_.GRRISTMC)
        {
            return true;
        }
        else if(rhs_.GRRISTMC < GRRISTMC)
        {
            return false;
        }
        if(GRRISOMC < rhs_.GRRISOMC)
        {
            return true;
        }
        else if(rhs_.GRRISOMC < GRRISOMC)
        {
            return false;
        }
        if(GRRISAMC < rhs_.GRRISAMC)
        {
            return true;
        }
        else if(rhs_.GRRISAMC < GRRISAMC)
        {
            return false;
        }
        if(GHITMC < rhs_.GHITMC)
        {
            return true;
        }
        else if(rhs_.GHITMC < GHITMC)
        {
            return false;
        }
        if(GHIOMC < rhs_.GHIOMC)
        {
            return true;
        }
        else if(rhs_.GHIOMC < GHIOMC)
        {
            return false;
        }
        if(GHIAMC < rhs_.GHIAMC)
        {
            return true;
        }
        else if(rhs_.GHIAMC < GHIAMC)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Yaoceyaokongsuju& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Yaoceyaokongsuju& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Yaoceyaokongsuju& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Yaoceyaokongsuju& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct ProgressAnalysis
{
    ::std::string taskCode;
    ::std::string branchCode;
    ::std::string type;
    ::std::string current;
    ::std::string total;

    bool operator==(const ProgressAnalysis& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(taskCode != rhs_.taskCode)
        {
            return false;
        }
        if(branchCode != rhs_.branchCode)
        {
            return false;
        }
        if(type != rhs_.type)
        {
            return false;
        }
        if(current != rhs_.current)
        {
            return false;
        }
        if(total != rhs_.total)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ProgressAnalysis& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(taskCode < rhs_.taskCode)
        {
            return true;
        }
        else if(rhs_.taskCode < taskCode)
        {
            return false;
        }
        if(branchCode < rhs_.branchCode)
        {
            return true;
        }
        else if(rhs_.branchCode < branchCode)
        {
            return false;
        }
        if(type < rhs_.type)
        {
            return true;
        }
        else if(rhs_.type < type)
        {
            return false;
        }
        if(current < rhs_.current)
        {
            return true;
        }
        else if(rhs_.current < current)
        {
            return false;
        }
        if(total < rhs_.total)
        {
            return true;
        }
        else if(rhs_.total < total)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ProgressAnalysis& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ProgressAnalysis& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ProgressAnalysis& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ProgressAnalysis& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct ProgressAllAnalysis
{
    ::std::string taskCode;
    ::std::string branchCode;
    ::std::string dwCurrent;
    ::std::string ccyCurrent;
    ::std::string l1aCurrent;
    ::std::string total;

    bool operator==(const ProgressAllAnalysis& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(taskCode != rhs_.taskCode)
        {
            return false;
        }
        if(branchCode != rhs_.branchCode)
        {
            return false;
        }
        if(dwCurrent != rhs_.dwCurrent)
        {
            return false;
        }
        if(ccyCurrent != rhs_.ccyCurrent)
        {
            return false;
        }
        if(l1aCurrent != rhs_.l1aCurrent)
        {
            return false;
        }
        if(total != rhs_.total)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ProgressAllAnalysis& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(taskCode < rhs_.taskCode)
        {
            return true;
        }
        else if(rhs_.taskCode < taskCode)
        {
            return false;
        }
        if(branchCode < rhs_.branchCode)
        {
            return true;
        }
        else if(rhs_.branchCode < branchCode)
        {
            return false;
        }
        if(dwCurrent < rhs_.dwCurrent)
        {
            return true;
        }
        else if(rhs_.dwCurrent < dwCurrent)
        {
            return false;
        }
        if(ccyCurrent < rhs_.ccyCurrent)
        {
            return true;
        }
        else if(rhs_.ccyCurrent < ccyCurrent)
        {
            return false;
        }
        if(l1aCurrent < rhs_.l1aCurrent)
        {
            return true;
        }
        else if(rhs_.l1aCurrent < l1aCurrent)
        {
            return false;
        }
        if(total < rhs_.total)
        {
            return true;
        }
        else if(rhs_.total < total)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ProgressAllAnalysis& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ProgressAllAnalysis& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ProgressAllAnalysis& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ProgressAllAnalysis& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct BandRegData
{
    ::std::string taskCode;
    ::std::string branchCode;
    ::std::string bandReg;

    bool operator==(const BandRegData& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(taskCode != rhs_.taskCode)
        {
            return false;
        }
        if(branchCode != rhs_.branchCode)
        {
            return false;
        }
        if(bandReg != rhs_.bandReg)
        {
            return false;
        }
        return true;
    }

    bool operator<(const BandRegData& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(taskCode < rhs_.taskCode)
        {
            return true;
        }
        else if(rhs_.taskCode < taskCode)
        {
            return false;
        }
        if(branchCode < rhs_.branchCode)
        {
            return true;
        }
        else if(rhs_.branchCode < branchCode)
        {
            return false;
        }
        if(bandReg < rhs_.bandReg)
        {
            return true;
        }
        else if(rhs_.bandReg < bandReg)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const BandRegData& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const BandRegData& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const BandRegData& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const BandRegData& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct TaskTime
{
    ::std::string id;
    ::std::string taskcode;
    ::std::string exdate;
    ::std::string l0receivedate;
    ::std::string l1acompletedate;
    ::std::string branchcode;

    bool operator==(const TaskTime& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(taskcode != rhs_.taskcode)
        {
            return false;
        }
        if(exdate != rhs_.exdate)
        {
            return false;
        }
        if(l0receivedate != rhs_.l0receivedate)
        {
            return false;
        }
        if(l1acompletedate != rhs_.l1acompletedate)
        {
            return false;
        }
        if(branchcode != rhs_.branchcode)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TaskTime& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(taskcode < rhs_.taskcode)
        {
            return true;
        }
        else if(rhs_.taskcode < taskcode)
        {
            return false;
        }
        if(exdate < rhs_.exdate)
        {
            return true;
        }
        else if(rhs_.exdate < exdate)
        {
            return false;
        }
        if(l0receivedate < rhs_.l0receivedate)
        {
            return true;
        }
        else if(rhs_.l0receivedate < l0receivedate)
        {
            return false;
        }
        if(l1acompletedate < rhs_.l1acompletedate)
        {
            return true;
        }
        else if(rhs_.l1acompletedate < l1acompletedate)
        {
            return false;
        }
        if(branchcode < rhs_.branchcode)
        {
            return true;
        }
        else if(rhs_.branchcode < branchcode)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TaskTime& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const TaskTime& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const TaskTime& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const TaskTime& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<TaskTime> TasksTime;

struct ErrlrCount
{
    ::Ice::Int level1;
    ::Ice::Int level2;
    ::Ice::Int level3;

    bool operator==(const ErrlrCount& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(level1 != rhs_.level1)
        {
            return false;
        }
        if(level2 != rhs_.level2)
        {
            return false;
        }
        if(level3 != rhs_.level3)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ErrlrCount& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(level1 < rhs_.level1)
        {
            return true;
        }
        else if(rhs_.level1 < level1)
        {
            return false;
        }
        if(level2 < rhs_.level2)
        {
            return true;
        }
        else if(rhs_.level2 < level2)
        {
            return false;
        }
        if(level3 < rhs_.level3)
        {
            return true;
        }
        else if(rhs_.level3 < level3)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ErrlrCount& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ErrlrCount& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ErrlrCount& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ErrlrCount& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace MDScallMPSService
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_LoginServiceProxy_LoginAuthentication.
 */
class Callback_LoginServiceProxy_LoginAuthentication_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LoginServiceProxy_LoginAuthentication_Base> Callback_LoginServiceProxy_LoginAuthenticationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_registerModule.
 */
class Callback_RegisterService_registerModule_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_registerModule_Base> Callback_RegisterService_registerModulePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_unregisterModule.
 */
class Callback_RegisterService_unregisterModule_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_unregisterModule_Base> Callback_RegisterService_unregisterModulePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestImage.
 */
class Callback_RegisterService_requestImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requestImage_Base> Callback_RegisterService_requestImagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestTaskList.
 */
class Callback_RegisterService_requestTaskList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requestTaskList_Base> Callback_RegisterService_requestTaskListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestSysOperPara.
 */
class Callback_RegisterService_requestSysOperPara_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requestSysOperPara_Base> Callback_RegisterService_requestSysOperParaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requsetSatPlatPara.
 */
class Callback_RegisterService_requsetSatPlatPara_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requsetSatPlatPara_Base> Callback_RegisterService_requsetSatPlatParaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requsetYaoCe.
 */
class Callback_RegisterService_requsetYaoCe_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requsetYaoCe_Base> Callback_RegisterService_requsetYaoCePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestOrbitData.
 */
class Callback_RegisterService_requestOrbitData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requestOrbitData_Base> Callback_RegisterService_requestOrbitDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_getFile.
 */
class Callback_RegisterService_getFile_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_getFile_Base> Callback_RegisterService_getFilePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestxyzData.
 */
class Callback_RegisterService_requestxyzData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requestxyzData_Base> Callback_RegisterService_requestxyzDataPtr;

}

namespace MPScallMDSService
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushUtcTime.
 */
class Callback_MDSService_pushUtcTime_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushUtcTime_Base> Callback_MDSService_pushUtcTimePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysOperPara.
 */
class Callback_MDSService_pushSysOperPara_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushSysOperPara_Base> Callback_MDSService_pushSysOperParaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSatPlatPara.
 */
class Callback_MDSService_pushSatPlatPara_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushSatPlatPara_Base> Callback_MDSService_pushSatPlatParaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskInfo.
 */
class Callback_MDSService_pushTaskInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushTaskInfo_Base> Callback_MDSService_pushTaskInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_imageReady.
 */
class Callback_MDSService_imageReady_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_imageReady_Base> Callback_MDSService_imageReadyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushErrorLog.
 */
class Callback_MDSService_pushErrorLog_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushErrorLog_Base> Callback_MDSService_pushErrorLogPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskStatus.
 */
class Callback_MDSService_pushTaskStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushTaskStatus_Base> Callback_MDSService_pushTaskStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushOrbitData.
 */
class Callback_MDSService_pushOrbitData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushOrbitData_Base> Callback_MDSService_pushOrbitDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushFFTData.
 */
class Callback_MDSService_pushFFTData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushFFTData_Base> Callback_MDSService_pushFFTDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushPQAData.
 */
class Callback_MDSService_pushPQAData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushPQAData_Base> Callback_MDSService_pushPQADataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTime.
 */
class Callback_MDSService_pushTime_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushTime_Base> Callback_MDSService_pushTimePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysLog.
 */
class Callback_MDSService_pushSysLog_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushSysLog_Base> Callback_MDSService_pushSysLogPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushInstruction.
 */
class Callback_MDSService_pushInstruction_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushInstruction_Base> Callback_MDSService_pushInstructionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushYaoceyaokongsuju.
 */
class Callback_MDSService_pushYaoceyaokongsuju_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushYaoceyaokongsuju_Base> Callback_MDSService_pushYaoceyaokongsujuPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushProgressAnalysis.
 */
class Callback_MDSService_pushProgressAnalysis_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushProgressAnalysis_Base> Callback_MDSService_pushProgressAnalysisPtr;

}

namespace IceProxy
{

namespace MDScallMPSService
{

class LoginServiceProxy : public virtual ::Ice::Proxy<LoginServiceProxy, ::IceProxy::Ice::Object>
{
public:

    bool LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_LoginAuthentication(_iceI_begin_LoginAuthentication(user, password, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LoginAuthentication(user, password, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::MDScallMPSService::Callback_LoginServiceProxy_LoginAuthenticationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context, const ::MDScallMPSService::Callback_LoginServiceProxy_LoginAuthenticationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, context, cb, cookie);
    }

    bool end_LoginAuthentication(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LoginAuthentication(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class RegisterService : public virtual ::Ice::Proxy<RegisterService, ::IceProxy::Ice::Object>
{
public:

    bool registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerModule(_iceI_begin_registerModule(modulename, host, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerModule(modulename, host, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::MDScallMPSService::Callback_RegisterService_registerModulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_registerModulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, context, cb, cookie);
    }

    bool end_registerModule(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerModule(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_unregisterModule(_iceI_begin_unregisterModule(modulename, host, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterModule(modulename, host, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterModule(modulename, host, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterModule(modulename, host, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::MDScallMPSService::Callback_RegisterService_unregisterModulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterModule(modulename, host, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_unregisterModulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterModule(modulename, host, context, cb, cookie);
    }

    bool end_unregisterModule(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterModule(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MDScallMPSService::ImageData requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requestImage(_iceI_begin_requestImage(level, branchcode, registration, channel, left, right, top, bottom, width, height, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requestImage(level, branchcode, registration, channel, left, right, top, bottom, width, height, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(level, branchcode, registration, channel, left, right, top, bottom, width, height, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(level, branchcode, registration, channel, left, right, top, bottom, width, height, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::MDScallMPSService::Callback_RegisterService_requestImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(level, branchcode, registration, channel, left, right, top, bottom, width, height, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requestImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(level, branchcode, registration, channel, left, right, top, bottom, width, height, context, cb, cookie);
    }

    ::MDScallMPSService::ImageData end_requestImage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requestImage(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_requestTaskList(_iceI_begin_requestTaskList(day, branchcode, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requestTaskList(day, branchcode, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestTaskList(day, branchcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestTaskList(day, branchcode, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::MDScallMPSService::Callback_RegisterService_requestTaskListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestTaskList(day, branchcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requestTaskListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestTaskList(day, branchcode, context, cb, cookie);
    }

    void end_requestTaskList(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requestTaskList(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string requestSysOperPara(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requestSysOperPara(_iceI_begin_requestSysOperPara(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requestSysOperPara(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requestSysOperPara(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestSysOperPara(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestSysOperPara(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestSysOperPara(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestSysOperPara(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestSysOperPara(const ::MDScallMPSService::Callback_RegisterService_requestSysOperParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestSysOperPara(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestSysOperPara(const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requestSysOperParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestSysOperPara(context, cb, cookie);
    }

    ::std::string end_requestSysOperPara(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requestSysOperPara(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string requsetSatPlatPara(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requsetSatPlatPara(_iceI_begin_requsetSatPlatPara(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requsetSatPlatPara(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requsetSatPlatPara(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requsetSatPlatPara(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetSatPlatPara(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requsetSatPlatPara(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetSatPlatPara(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requsetSatPlatPara(const ::MDScallMPSService::Callback_RegisterService_requsetSatPlatParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetSatPlatPara(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requsetSatPlatPara(const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requsetSatPlatParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetSatPlatPara(context, cb, cookie);
    }

    ::std::string end_requsetSatPlatPara(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requsetSatPlatPara(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MDScallMPSService::ImageData requsetYaoCe(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requsetYaoCe(_iceI_begin_requsetYaoCe(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requsetYaoCe(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requsetYaoCe(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requsetYaoCe(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetYaoCe(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requsetYaoCe(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetYaoCe(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requsetYaoCe(const ::MDScallMPSService::Callback_RegisterService_requsetYaoCePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetYaoCe(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requsetYaoCe(const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requsetYaoCePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requsetYaoCe(context, cb, cookie);
    }

    ::MDScallMPSService::ImageData end_requsetYaoCe(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requsetYaoCe(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string requestOrbitData(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requestOrbitData(_iceI_begin_requestOrbitData(time, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requestOrbitData(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requestOrbitData(time, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestOrbitData(const ::std::string& time, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestOrbitData(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestOrbitData(const ::std::string& time, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestOrbitData(time, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestOrbitData(const ::std::string& time, const ::MDScallMPSService::Callback_RegisterService_requestOrbitDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestOrbitData(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestOrbitData(const ::std::string& time, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requestOrbitDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestOrbitData(time, context, cb, cookie);
    }

    ::std::string end_requestOrbitData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requestOrbitData(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MDScallMPSService::ImageData getFile(const ::std::string& filename, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getFile(_iceI_begin_getFile(filename, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getFile(const ::std::string& filename, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getFile(filename, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFile(const ::std::string& filename, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFile(filename, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFile(const ::std::string& filename, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFile(filename, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFile(const ::std::string& filename, const ::MDScallMPSService::Callback_RegisterService_getFilePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFile(filename, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFile(const ::std::string& filename, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_getFilePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFile(filename, context, cb, cookie);
    }

    ::MDScallMPSService::ImageData end_getFile(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getFile(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MDScallMPSService::XYZDATA requestxyzData(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requestxyzData(_iceI_begin_requestxyzData(time, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requestxyzData(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requestxyzData(time, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestxyzData(const ::std::string& time, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestxyzData(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestxyzData(const ::std::string& time, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestxyzData(time, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestxyzData(const ::std::string& time, const ::MDScallMPSService::Callback_RegisterService_requestxyzDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestxyzData(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestxyzData(const ::std::string& time, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requestxyzDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestxyzData(time, context, cb, cookie);
    }

    ::MDScallMPSService::XYZDATA end_requestxyzData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requestxyzData(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace MPScallMDSService
{

class MDSService : public virtual ::Ice::Proxy<MDSService, ::IceProxy::Ice::Object>
{
public:

    void pushUtcTime(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushUtcTime(_iceI_begin_pushUtcTime(time, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushUtcTime(time, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::MPScallMDSService::Callback_MDSService_pushUtcTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushUtcTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, context, cb, cookie);
    }

    void end_pushUtcTime(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushUtcTime(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushSysOperPara(_iceI_begin_pushSysOperPara(para, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushSysOperPara(para, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::MPScallMDSService::Callback_MDSService_pushSysOperParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushSysOperParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, context, cb, cookie);
    }

    void end_pushSysOperPara(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushSatPlatPara(_iceI_begin_pushSatPlatPara(para, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushSatPlatPara(para, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::MPScallMDSService::Callback_MDSService_pushSatPlatParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushSatPlatParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, context, cb, cookie);
    }

    void end_pushSatPlatPara(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushTaskInfo(_iceI_begin_pushTaskInfo(branchCode, tasks, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::MPScallMDSService::Callback_MDSService_pushTaskInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushTaskInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, context, cb, cookie);
    }

    void end_pushTaskInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushTaskInfo(const ::std::string&, const ::MPScallMDSService::TasksData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_imageReady(_iceI_begin_imageReady(type, branch, Registration, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_imageReady(type, branch, Registration, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, branch, Registration, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, branch, Registration, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::MPScallMDSService::Callback_MDSService_imageReadyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, branch, Registration, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_imageReadyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, branch, Registration, context, cb, cookie);
    }

    void end_imageReady(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_imageReady(const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushErrorLog(_iceI_begin_pushErrorLog(log, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushErrorLog(log, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::MPScallMDSService::Callback_MDSService_pushErrorLogPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushErrorLogPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, context, cb, cookie);
    }

    void end_pushErrorLog(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushErrorLog(const ::MPScallMDSService::ErrorLog&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushTaskStatus(const ::MPScallMDSService::TaskStatus& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushTaskStatus(_iceI_begin_pushTaskStatus(status, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushTaskStatus(const ::MPScallMDSService::TaskStatus& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushTaskStatus(status, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushTaskStatus(const ::MPScallMDSService::TaskStatus& status, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskStatus(status, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskStatus(const ::MPScallMDSService::TaskStatus& status, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskStatus(status, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskStatus(const ::MPScallMDSService::TaskStatus& status, const ::MPScallMDSService::Callback_MDSService_pushTaskStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskStatus(status, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskStatus(const ::MPScallMDSService::TaskStatus& status, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushTaskStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskStatus(status, context, cb, cookie);
    }

    void end_pushTaskStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushTaskStatus(const ::MPScallMDSService::TaskStatus&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushOrbitData(const ::MPScallMDSService::OrbitData& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushOrbitData(_iceI_begin_pushOrbitData(data, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushOrbitData(const ::MPScallMDSService::OrbitData& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushOrbitData(data, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushOrbitData(const ::MPScallMDSService::OrbitData& data, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushOrbitData(data, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushOrbitData(const ::MPScallMDSService::OrbitData& data, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushOrbitData(data, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushOrbitData(const ::MPScallMDSService::OrbitData& data, const ::MPScallMDSService::Callback_MDSService_pushOrbitDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushOrbitData(data, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushOrbitData(const ::MPScallMDSService::OrbitData& data, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushOrbitDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushOrbitData(data, context, cb, cookie);
    }

    void end_pushOrbitData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushOrbitData(const ::MPScallMDSService::OrbitData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushFFTData(const ::MPScallMDSService::FFTDATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushFFTData(_iceI_begin_pushFFTData(data, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushFFTData(const ::MPScallMDSService::FFTDATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushFFTData(data, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushFFTData(const ::MPScallMDSService::FFTDATA& data, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushFFTData(data, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushFFTData(const ::MPScallMDSService::FFTDATA& data, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushFFTData(data, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushFFTData(const ::MPScallMDSService::FFTDATA& data, const ::MPScallMDSService::Callback_MDSService_pushFFTDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushFFTData(data, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushFFTData(const ::MPScallMDSService::FFTDATA& data, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushFFTDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushFFTData(data, context, cb, cookie);
    }

    void end_pushFFTData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushFFTData(const ::MPScallMDSService::FFTDATA&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushPQAData(const ::MPScallMDSService::PQADATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushPQAData(_iceI_begin_pushPQAData(data, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushPQAData(const ::MPScallMDSService::PQADATA& data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushPQAData(data, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushPQAData(const ::MPScallMDSService::PQADATA& data, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushPQAData(data, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushPQAData(const ::MPScallMDSService::PQADATA& data, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushPQAData(data, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushPQAData(const ::MPScallMDSService::PQADATA& data, const ::MPScallMDSService::Callback_MDSService_pushPQADataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushPQAData(data, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushPQAData(const ::MPScallMDSService::PQADATA& data, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushPQADataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushPQAData(data, context, cb, cookie);
    }

    void end_pushPQAData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushPQAData(const ::MPScallMDSService::PQADATA&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushTime(_iceI_begin_pushTime(type, branchCode, time, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushTime(type, branchCode, time, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTime(type, branchCode, time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTime(type, branchCode, time, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::MPScallMDSService::Callback_MDSService_pushTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTime(type, branchCode, time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTime(type, branchCode, time, context, cb, cookie);
    }

    void end_pushTime(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushTime(const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushSysLog(const ::MPScallMDSService::SysLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushSysLog(_iceI_begin_pushSysLog(log, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushSysLog(const ::MPScallMDSService::SysLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushSysLog(log, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushSysLog(const ::MPScallMDSService::SysLog& log, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysLog(log, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysLog(const ::MPScallMDSService::SysLog& log, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysLog(log, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysLog(const ::MPScallMDSService::SysLog& log, const ::MPScallMDSService::Callback_MDSService_pushSysLogPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysLog(log, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysLog(const ::MPScallMDSService::SysLog& log, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushSysLogPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysLog(log, context, cb, cookie);
    }

    void end_pushSysLog(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushSysLog(const ::MPScallMDSService::SysLog&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushInstruction(const ::MPScallMDSService::Instruction& ins, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushInstruction(_iceI_begin_pushInstruction(ins, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushInstruction(const ::MPScallMDSService::Instruction& ins, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushInstruction(ins, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushInstruction(const ::MPScallMDSService::Instruction& ins, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushInstruction(ins, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushInstruction(const ::MPScallMDSService::Instruction& ins, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushInstruction(ins, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushInstruction(const ::MPScallMDSService::Instruction& ins, const ::MPScallMDSService::Callback_MDSService_pushInstructionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushInstruction(ins, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushInstruction(const ::MPScallMDSService::Instruction& ins, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushInstructionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushInstruction(ins, context, cb, cookie);
    }

    void end_pushInstruction(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushInstruction(const ::MPScallMDSService::Instruction&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju& yaoce, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushYaoceyaokongsuju(_iceI_begin_pushYaoceyaokongsuju(yaoce, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju& yaoce, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushYaoceyaokongsuju(yaoce, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju& yaoce, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushYaoceyaokongsuju(yaoce, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju& yaoce, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushYaoceyaokongsuju(yaoce, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju& yaoce, const ::MPScallMDSService::Callback_MDSService_pushYaoceyaokongsujuPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushYaoceyaokongsuju(yaoce, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju& yaoce, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushYaoceyaokongsujuPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushYaoceyaokongsuju(yaoce, context, cb, cookie);
    }

    void end_pushYaoceyaokongsuju(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushYaoceyaokongsuju(const ::MPScallMDSService::Yaoceyaokongsuju&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis& pa, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushProgressAnalysis(_iceI_begin_pushProgressAnalysis(pa, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis& pa, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushProgressAnalysis(pa, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis& pa, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushProgressAnalysis(pa, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis& pa, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushProgressAnalysis(pa, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis& pa, const ::MPScallMDSService::Callback_MDSService_pushProgressAnalysisPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushProgressAnalysis(pa, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis& pa, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushProgressAnalysisPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushProgressAnalysis(pa, context, cb, cookie);
    }

    void end_pushProgressAnalysis(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushProgressAnalysis(const ::MPScallMDSService::ProgressAnalysis&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace MDScallMPSService
{

class LoginServiceProxy : public virtual ::Ice::Object
{
public:

    typedef LoginServiceProxyPrx ProxyType;
    typedef LoginServiceProxyPtr PointerType;

    virtual ~LoginServiceProxy();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_LoginAuthentication(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const LoginServiceProxy& lhs, const LoginServiceProxy& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LoginServiceProxy& lhs, const LoginServiceProxy& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class RegisterService : public virtual ::Ice::Object
{
public:

    typedef RegisterServicePrx ProxyType;
    typedef RegisterServicePtr PointerType;

    virtual ~RegisterService();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerModule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool unregisterModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterModule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData requestImage(const ::std::string& level, const ::std::string& branchcode, const ::std::string& registration, const ::std::string& channel, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requestImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void requestTaskList(const ::std::string& day, const ::std::string& branchcode, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requestTaskList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string requestSysOperPara(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requestSysOperPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string requsetSatPlatPara(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requsetSatPlatPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData requsetYaoCe(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requsetYaoCe(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string requestOrbitData(const ::std::string& time, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requestOrbitData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData getFile(const ::std::string& filename, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getFile(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual XYZDATA requestxyzData(const ::std::string& time, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requestxyzData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const RegisterService& lhs, const RegisterService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const RegisterService& lhs, const RegisterService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace MPScallMDSService
{

class MDSService : public virtual ::Ice::Object
{
public:

    typedef MDSServicePrx ProxyType;
    typedef MDSServicePtr PointerType;

    virtual ~MDSService();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void pushUtcTime(const ::std::string& time, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushUtcTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSysOperPara(const SysOperPara& para, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSysOperPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSatPlatPara(const SatPlatPara& para, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSatPlatPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTaskInfo(const ::std::string& branchCode, const TasksData& tasks, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTaskInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void imageReady(const ::std::string& type, const ::std::string& branch, const ::std::string& Registration, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_imageReady(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushErrorLog(const ErrorLog& log, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushErrorLog(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTaskStatus(const TaskStatus& status, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTaskStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushOrbitData(const OrbitData& data, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushOrbitData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushFFTData(const FFTDATA& data, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushFFTData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushPQAData(const PQADATA& data, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushPQAData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTime(const ::std::string& type, const ::std::string& branchCode, const ::std::string& time, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSysLog(const SysLog& log, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSysLog(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushInstruction(const Instruction& ins, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushInstruction(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushYaoceyaokongsuju(const Yaoceyaokongsuju& yaoce, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushYaoceyaokongsuju(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushProgressAnalysis(const ProgressAnalysis& pa, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushProgressAnalysis(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MDSService& lhs, const MDSService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MDSService& lhs, const MDSService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::MDScallMPSService::XYZDATA>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MDScallMPSService::XYZDATA, S>
{
    static void write(S* ostr, const ::MDScallMPSService::XYZDATA& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::MDScallMPSService::XYZDATA, S>
{
    static void read(S* istr, ::MDScallMPSService::XYZDATA& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
    }
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::MPScallMDSService::SysOperPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 44;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::SysOperPara, S>
{
    static void write(S* ostr, const ::MPScallMDSService::SysOperPara& v)
    {
        ostr->write(v.ParamType);
        ostr->write(v.SatID);
        ostr->write(v.GIIRSTeleCmdTime);
        ostr->write(v.GIIRSTeleCmdPushCycle);
        ostr->write(v.AGRITeleCmdPushCycle);
        ostr->write(v.AGRITeleCmdTime);
        ostr->write(v.RSITeleCmdPushCycle);
        ostr->write(v.RSITeleCmdTime);
        ostr->write(v.GIIRSAMC);
        ostr->write(v.GIIRSOMC);
        ostr->write(v.AGRITMC);
        ostr->write(v.RSIINRFLOW);
        ostr->write(v.GRIISINRFLOW);
        ostr->write(v.AGRIAMC);
        ostr->write(v.AGRIOMC);
        ostr->write(v.AGRIXINRFLOW);
        ostr->write(v.GIIRSTMC);
        ostr->write(v.RSIAMC);
        ostr->write(v.RSIOMC);
        ostr->write(v.RSITMC);
        ostr->write(v.GIIRSNRS);
        ostr->write(v.AGRINRS);
        ostr->write(v.RSINRS);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::SysOperPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SysOperPara& v)
    {
        istr->read(v.ParamType);
        istr->read(v.SatID);
        istr->read(v.GIIRSTeleCmdTime);
        istr->read(v.GIIRSTeleCmdPushCycle);
        istr->read(v.AGRITeleCmdPushCycle);
        istr->read(v.AGRITeleCmdTime);
        istr->read(v.RSITeleCmdPushCycle);
        istr->read(v.RSITeleCmdTime);
        istr->read(v.GIIRSAMC);
        istr->read(v.GIIRSOMC);
        istr->read(v.AGRITMC);
        istr->read(v.RSIINRFLOW);
        istr->read(v.GRIISINRFLOW);
        istr->read(v.AGRIAMC);
        istr->read(v.AGRIOMC);
        istr->read(v.AGRIXINRFLOW);
        istr->read(v.GIIRSTMC);
        istr->read(v.RSIAMC);
        istr->read(v.RSIOMC);
        istr->read(v.RSITMC);
        istr->read(v.GIIRSNRS);
        istr->read(v.AGRINRS);
        istr->read(v.RSINRS);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::SatPlatPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 42;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::SatPlatPara, S>
{
    static void write(S* ostr, const ::MPScallMDSService::SatPlatPara& v)
    {
        ostr->write(v.ParamType);
        ostr->write(v.SatID);
        ostr->write(v.GIIRSTmcTranCh);
        ostr->write(v.AGRITmcTranCh);
        ostr->write(v.FlutterTranCh);
        ostr->write(v.INRDataTranCh);
        ostr->write(v.SatSenserTranCh);
        ostr->write(v.FixedPosRegTranCh);
        ostr->write(v.SEPDataTranCh);
        ostr->write(v.RSIDataTranCh);
        ostr->write(v.AGRIDataTranCh);
        ostr->write(v.GIIRSProDataTranCh);
        ostr->write(v.GIIRSRawDataTranCh);
        ostr->write(v.DataTranRightCh);
        ostr->write(v.DataTranLeftCh);
        ostr->write(v.OrbitConWorkSta);
        ostr->write(v.ImagePositionSta);
        ostr->write(v.SatColScreenFace);
        ostr->write(v.NorOrbAngleRange);
        ostr->write(v.FGMWorkStatus);
        ostr->write(v.RADDWorkStatus);
        ostr->write(v.HEPDWorkStatus);
        ostr->write(v.CPDWorkStatus);
        ostr->write(v.RSIWorkStatus);
        ostr->write(v.GIIRSWorkStatus);
        ostr->write(v.AGRIWorkStatus);
        ostr->write(v.SatWorkStatus);
        ostr->write(v.OrbitLocation);
        ostr->write(v.RSITmcTranCh);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::SatPlatPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SatPlatPara& v)
    {
        istr->read(v.ParamType);
        istr->read(v.SatID);
        istr->read(v.GIIRSTmcTranCh);
        istr->read(v.AGRITmcTranCh);
        istr->read(v.FlutterTranCh);
        istr->read(v.INRDataTranCh);
        istr->read(v.SatSenserTranCh);
        istr->read(v.FixedPosRegTranCh);
        istr->read(v.SEPDataTranCh);
        istr->read(v.RSIDataTranCh);
        istr->read(v.AGRIDataTranCh);
        istr->read(v.GIIRSProDataTranCh);
        istr->read(v.GIIRSRawDataTranCh);
        istr->read(v.DataTranRightCh);
        istr->read(v.DataTranLeftCh);
        istr->read(v.OrbitConWorkSta);
        istr->read(v.ImagePositionSta);
        istr->read(v.SatColScreenFace);
        istr->read(v.NorOrbAngleRange);
        istr->read(v.FGMWorkStatus);
        istr->read(v.RADDWorkStatus);
        istr->read(v.HEPDWorkStatus);
        istr->read(v.CPDWorkStatus);
        istr->read(v.RSIWorkStatus);
        istr->read(v.GIIRSWorkStatus);
        istr->read(v.AGRIWorkStatus);
        istr->read(v.SatWorkStatus);
        istr->read(v.OrbitLocation);
        istr->read(v.RSITmcTranCh);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::Task>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::Task, S>
{
    static void write(S* ostr, const ::MPScallMDSService::Task& v)
    {
        ostr->write(v.TaskEN);
        ostr->write(v.TaskCN);
        ostr->write(v.TaskCode);
        ostr->write(v.Exdate);
        ostr->write(v.StartTime);
        ostr->write(v.EndTime);
        ostr->write(v.ExStatus);
        ostr->write(v.RealStartTime);
        ostr->write(v.RealEndTime);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::Task, S>
{
    static void read(S* istr, ::MPScallMDSService::Task& v)
    {
        istr->read(v.TaskEN);
        istr->read(v.TaskCN);
        istr->read(v.TaskCode);
        istr->read(v.Exdate);
        istr->read(v.StartTime);
        istr->read(v.EndTime);
        istr->read(v.ExStatus);
        istr->read(v.RealStartTime);
        istr->read(v.RealEndTime);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::ErrorLog>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::ErrorLog, S>
{
    static void write(S* ostr, const ::MPScallMDSService::ErrorLog& v)
    {
        ostr->write(v.branchcode);
        ostr->write(v.errorlevel);
        ostr->write(v.status);
        ostr->write(v.time);
        ostr->write(v.taskcode);
        ostr->write(v.message);
        ostr->write(v.errorcode);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::ErrorLog, S>
{
    static void read(S* istr, ::MPScallMDSService::ErrorLog& v)
    {
        istr->read(v.branchcode);
        istr->read(v.errorlevel);
        istr->read(v.status);
        istr->read(v.time);
        istr->read(v.taskcode);
        istr->read(v.message);
        istr->read(v.errorcode);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::TaskStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::TaskStatus, S>
{
    static void write(S* ostr, const ::MPScallMDSService::TaskStatus& v)
    {
        ostr->write(v.branchcode);
        ostr->write(v.taskcode);
        ostr->write(v.status);
        ostr->write(v.dealtag);
        ostr->write(v.time);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::TaskStatus, S>
{
    static void read(S* istr, ::MPScallMDSService::TaskStatus& v)
    {
        istr->read(v.branchcode);
        istr->read(v.taskcode);
        istr->read(v.status);
        istr->read(v.dealtag);
        istr->read(v.time);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::OrbitData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::OrbitData, S>
{
    static void write(S* ostr, const ::MPScallMDSService::OrbitData& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::OrbitData, S>
{
    static void read(S* istr, ::MPScallMDSService::OrbitData& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::FFTDATA>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::FFTDATA, S>
{
    static void write(S* ostr, const ::MPScallMDSService::FFTDATA& v)
    {
        ostr->write(v.rolling);
        ostr->write(v.pitch);
        ostr->write(v.yaw);
        ostr->write(v.dipAngle);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::FFTDATA, S>
{
    static void read(S* istr, ::MPScallMDSService::FFTDATA& v)
    {
        istr->read(v.rolling);
        istr->read(v.pitch);
        istr->read(v.yaw);
        istr->read(v.dipAngle);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::PQADATA>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::PQADATA, S>
{
    static void write(S* ostr, const ::MPScallMDSService::PQADATA& v)
    {
        ostr->write(v.branch);
        ostr->write(v.taskcode);
        ostr->write(v.time);
        ostr->write(v.Band1);
        ostr->write(v.Band2);
        ostr->write(v.Band3);
        ostr->write(v.Band4);
        ostr->write(v.Band5);
        ostr->write(v.Band6);
        ostr->write(v.Band7);
        ostr->write(v.Band8);
        ostr->write(v.Band9);
        ostr->write(v.Band10);
        ostr->write(v.Band11);
        ostr->write(v.Band12);
        ostr->write(v.Band13);
        ostr->write(v.Band14);
        ostr->write(v.Band15);
        ostr->write(v.Band16);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::PQADATA, S>
{
    static void read(S* istr, ::MPScallMDSService::PQADATA& v)
    {
        istr->read(v.branch);
        istr->read(v.taskcode);
        istr->read(v.time);
        istr->read(v.Band1);
        istr->read(v.Band2);
        istr->read(v.Band3);
        istr->read(v.Band4);
        istr->read(v.Band5);
        istr->read(v.Band6);
        istr->read(v.Band7);
        istr->read(v.Band8);
        istr->read(v.Band9);
        istr->read(v.Band10);
        istr->read(v.Band11);
        istr->read(v.Band12);
        istr->read(v.Band13);
        istr->read(v.Band14);
        istr->read(v.Band15);
        istr->read(v.Band16);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::SysLog>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::SysLog, S>
{
    static void write(S* ostr, const ::MPScallMDSService::SysLog& v)
    {
        ostr->write(v.branchcode);
        ostr->write(v.logattri);
        ostr->write(v.time);
        ostr->write(v.taskcode);
        ostr->write(v.message);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::SysLog, S>
{
    static void read(S* istr, ::MPScallMDSService::SysLog& v)
    {
        istr->read(v.branchcode);
        istr->read(v.logattri);
        istr->read(v.time);
        istr->read(v.taskcode);
        istr->read(v.message);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::Instruction>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::Instruction, S>
{
    static void write(S* ostr, const ::MPScallMDSService::Instruction& v)
    {
        ostr->write(v.type);
        ostr->write(v.satcode);
        ostr->write(v.scheduletype);
        ostr->write(v.modifytime);
        ostr->write(v.dealtime);
        ostr->write(v.status);
        ostr->write(v.desc);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::Instruction, S>
{
    static void read(S* istr, ::MPScallMDSService::Instruction& v)
    {
        istr->read(v.type);
        istr->read(v.satcode);
        istr->read(v.scheduletype);
        istr->read(v.modifytime);
        istr->read(v.dealtime);
        istr->read(v.status);
        istr->read(v.desc);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::Yaoceyaokongsuju>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::Yaoceyaokongsuju, S>
{
    static void write(S* ostr, const ::MPScallMDSService::Yaoceyaokongsuju& v)
    {
        ostr->write(v.FLCX);
        ostr->write(v.XXD);
        ostr->write(v.SDNX);
        ostr->write(v.ZTDNX);
        ostr->write(v.XMa);
        ostr->write(v.XMb);
        ostr->write(v.XMc);
        ostr->write(v.FFTC);
        ostr->write(v.AGRIXBC);
        ostr->write(v.GRRISBC);
        ostr->write(v.GHIBC);
        ostr->write(v.AGRIXTMC);
        ostr->write(v.AGRIXOMC);
        ostr->write(v.AGRIXAMC);
        ostr->write(v.GRRISTMC);
        ostr->write(v.GRRISOMC);
        ostr->write(v.GRRISAMC);
        ostr->write(v.GHITMC);
        ostr->write(v.GHIOMC);
        ostr->write(v.GHIAMC);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::Yaoceyaokongsuju, S>
{
    static void read(S* istr, ::MPScallMDSService::Yaoceyaokongsuju& v)
    {
        istr->read(v.FLCX);
        istr->read(v.XXD);
        istr->read(v.SDNX);
        istr->read(v.ZTDNX);
        istr->read(v.XMa);
        istr->read(v.XMb);
        istr->read(v.XMc);
        istr->read(v.FFTC);
        istr->read(v.AGRIXBC);
        istr->read(v.GRRISBC);
        istr->read(v.GHIBC);
        istr->read(v.AGRIXTMC);
        istr->read(v.AGRIXOMC);
        istr->read(v.AGRIXAMC);
        istr->read(v.GRRISTMC);
        istr->read(v.GRRISOMC);
        istr->read(v.GRRISAMC);
        istr->read(v.GHITMC);
        istr->read(v.GHIOMC);
        istr->read(v.GHIAMC);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::ProgressAnalysis>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::ProgressAnalysis, S>
{
    static void write(S* ostr, const ::MPScallMDSService::ProgressAnalysis& v)
    {
        ostr->write(v.taskCode);
        ostr->write(v.branchCode);
        ostr->write(v.type);
        ostr->write(v.current);
        ostr->write(v.total);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::ProgressAnalysis, S>
{
    static void read(S* istr, ::MPScallMDSService::ProgressAnalysis& v)
    {
        istr->read(v.taskCode);
        istr->read(v.branchCode);
        istr->read(v.type);
        istr->read(v.current);
        istr->read(v.total);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::ProgressAllAnalysis>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::ProgressAllAnalysis, S>
{
    static void write(S* ostr, const ::MPScallMDSService::ProgressAllAnalysis& v)
    {
        ostr->write(v.taskCode);
        ostr->write(v.branchCode);
        ostr->write(v.dwCurrent);
        ostr->write(v.ccyCurrent);
        ostr->write(v.l1aCurrent);
        ostr->write(v.total);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::ProgressAllAnalysis, S>
{
    static void read(S* istr, ::MPScallMDSService::ProgressAllAnalysis& v)
    {
        istr->read(v.taskCode);
        istr->read(v.branchCode);
        istr->read(v.dwCurrent);
        istr->read(v.ccyCurrent);
        istr->read(v.l1aCurrent);
        istr->read(v.total);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::BandRegData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::BandRegData, S>
{
    static void write(S* ostr, const ::MPScallMDSService::BandRegData& v)
    {
        ostr->write(v.taskCode);
        ostr->write(v.branchCode);
        ostr->write(v.bandReg);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::BandRegData, S>
{
    static void read(S* istr, ::MPScallMDSService::BandRegData& v)
    {
        istr->read(v.taskCode);
        istr->read(v.branchCode);
        istr->read(v.bandReg);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::TaskTime>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::TaskTime, S>
{
    static void write(S* ostr, const ::MPScallMDSService::TaskTime& v)
    {
        ostr->write(v.id);
        ostr->write(v.taskcode);
        ostr->write(v.exdate);
        ostr->write(v.l0receivedate);
        ostr->write(v.l1acompletedate);
        ostr->write(v.branchcode);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::TaskTime, S>
{
    static void read(S* istr, ::MPScallMDSService::TaskTime& v)
    {
        istr->read(v.id);
        istr->read(v.taskcode);
        istr->read(v.exdate);
        istr->read(v.l0receivedate);
        istr->read(v.l1acompletedate);
        istr->read(v.branchcode);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::ErrlrCount>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::ErrlrCount, S>
{
    static void write(S* ostr, const ::MPScallMDSService::ErrlrCount& v)
    {
        ostr->write(v.level1);
        ostr->write(v.level2);
        ostr->write(v.level3);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::ErrlrCount, S>
{
    static void read(S* istr, ::MPScallMDSService::ErrlrCount& v)
    {
        istr->read(v.level1);
        istr->read(v.level2);
        istr->read(v.level3);
    }
};

}
/// \endcond

namespace MDScallMPSService
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_LoginServiceProxy_LoginAuthentication.
 */
template<class T>
class CallbackNC_LoginServiceProxy_LoginAuthentication : public Callback_LoginServiceProxy_LoginAuthentication_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LoginServiceProxy_LoginAuthentication(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LoginServiceProxyPrx proxy = LoginServiceProxyPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LoginAuthentication(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LoginServiceProxy_LoginAuthentication<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LoginServiceProxy_LoginAuthentication<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_LoginServiceProxy_LoginAuthentication.
 */
template<class T, typename CT>
class Callback_LoginServiceProxy_LoginAuthentication : public Callback_LoginServiceProxy_LoginAuthentication_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LoginServiceProxy_LoginAuthentication(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LoginServiceProxyPrx proxy = LoginServiceProxyPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LoginAuthentication(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T, typename CT> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LoginServiceProxy_LoginAuthentication<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T, typename CT> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LoginServiceProxy_LoginAuthentication<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_registerModule.
 */
template<class T>
class CallbackNC_RegisterService_registerModule : public Callback_RegisterService_registerModule_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RegisterService_registerModule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_registerModule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_registerModule<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_registerModule<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_registerModule.
 */
template<class T, typename CT>
class Callback_RegisterService_registerModule : public Callback_RegisterService_registerModule_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RegisterService_registerModule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_registerModule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T, typename CT> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_registerModule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T, typename CT> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_registerModule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_unregisterModule.
 */
template<class T>
class CallbackNC_RegisterService_unregisterModule : public Callback_RegisterService_unregisterModule_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RegisterService_unregisterModule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_unregisterModule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 */
template<class T> Callback_RegisterService_unregisterModulePtr
newCallback_RegisterService_unregisterModule(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_unregisterModule<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 */
template<class T> Callback_RegisterService_unregisterModulePtr
newCallback_RegisterService_unregisterModule(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_unregisterModule<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_unregisterModule.
 */
template<class T, typename CT>
class Callback_RegisterService_unregisterModule : public Callback_RegisterService_unregisterModule_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RegisterService_unregisterModule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_unregisterModule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 */
template<class T, typename CT> Callback_RegisterService_unregisterModulePtr
newCallback_RegisterService_unregisterModule(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_unregisterModule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_unregisterModule.
 */
template<class T, typename CT> Callback_RegisterService_unregisterModulePtr
newCallback_RegisterService_unregisterModule(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_unregisterModule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestImage.
 */
template<class T>
class CallbackNC_RegisterService_requestImage : public Callback_RegisterService_requestImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ImageData&);

    CallbackNC_RegisterService_requestImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_requestImage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(T* instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestImage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestImage.
 */
template<class T, typename CT>
class Callback_RegisterService_requestImage : public Callback_RegisterService_requestImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ImageData&, const CT&);

    Callback_RegisterService_requestImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_requestImage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T, typename CT> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T, typename CT> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(T* instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestTaskList.
 */
template<class T>
class CallbackNC_RegisterService_requestTaskList : public Callback_RegisterService_requestTaskList_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RegisterService_requestTaskList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestTaskList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestTaskList<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestTaskList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestTaskList<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestTaskList.
 */
template<class T, typename CT>
class Callback_RegisterService_requestTaskList : public Callback_RegisterService_requestTaskList_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RegisterService_requestTaskList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T, typename CT> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestTaskList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T, typename CT> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestTaskList<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T, typename CT> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestTaskList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestTaskList.
 */
template<class T, typename CT> Callback_RegisterService_requestTaskListPtr
newCallback_RegisterService_requestTaskList(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestTaskList<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestSysOperPara.
 */
template<class T>
class CallbackNC_RegisterService_requestSysOperPara : public Callback_RegisterService_requestSysOperPara_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RegisterService_requestSysOperPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_requestSysOperPara(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 */
template<class T> Callback_RegisterService_requestSysOperParaPtr
newCallback_RegisterService_requestSysOperPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestSysOperPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 */
template<class T> Callback_RegisterService_requestSysOperParaPtr
newCallback_RegisterService_requestSysOperPara(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestSysOperPara<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestSysOperPara.
 */
template<class T, typename CT>
class Callback_RegisterService_requestSysOperPara : public Callback_RegisterService_requestSysOperPara_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RegisterService_requestSysOperPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_requestSysOperPara(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 */
template<class T, typename CT> Callback_RegisterService_requestSysOperParaPtr
newCallback_RegisterService_requestSysOperPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestSysOperPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestSysOperPara.
 */
template<class T, typename CT> Callback_RegisterService_requestSysOperParaPtr
newCallback_RegisterService_requestSysOperPara(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestSysOperPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requsetSatPlatPara.
 */
template<class T>
class CallbackNC_RegisterService_requsetSatPlatPara : public Callback_RegisterService_requsetSatPlatPara_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RegisterService_requsetSatPlatPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_requsetSatPlatPara(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 */
template<class T> Callback_RegisterService_requsetSatPlatParaPtr
newCallback_RegisterService_requsetSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requsetSatPlatPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 */
template<class T> Callback_RegisterService_requsetSatPlatParaPtr
newCallback_RegisterService_requsetSatPlatPara(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requsetSatPlatPara<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requsetSatPlatPara.
 */
template<class T, typename CT>
class Callback_RegisterService_requsetSatPlatPara : public Callback_RegisterService_requsetSatPlatPara_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RegisterService_requsetSatPlatPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_requsetSatPlatPara(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 */
template<class T, typename CT> Callback_RegisterService_requsetSatPlatParaPtr
newCallback_RegisterService_requsetSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requsetSatPlatPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetSatPlatPara.
 */
template<class T, typename CT> Callback_RegisterService_requsetSatPlatParaPtr
newCallback_RegisterService_requsetSatPlatPara(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requsetSatPlatPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requsetYaoCe.
 */
template<class T>
class CallbackNC_RegisterService_requsetYaoCe : public Callback_RegisterService_requsetYaoCe_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ImageData&);

    CallbackNC_RegisterService_requsetYaoCe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_requsetYaoCe(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 */
template<class T> Callback_RegisterService_requsetYaoCePtr
newCallback_RegisterService_requsetYaoCe(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requsetYaoCe<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 */
template<class T> Callback_RegisterService_requsetYaoCePtr
newCallback_RegisterService_requsetYaoCe(T* instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requsetYaoCe<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requsetYaoCe.
 */
template<class T, typename CT>
class Callback_RegisterService_requsetYaoCe : public Callback_RegisterService_requsetYaoCe_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ImageData&, const CT&);

    Callback_RegisterService_requsetYaoCe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_requsetYaoCe(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 */
template<class T, typename CT> Callback_RegisterService_requsetYaoCePtr
newCallback_RegisterService_requsetYaoCe(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requsetYaoCe<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requsetYaoCe.
 */
template<class T, typename CT> Callback_RegisterService_requsetYaoCePtr
newCallback_RegisterService_requsetYaoCe(T* instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requsetYaoCe<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestOrbitData.
 */
template<class T>
class CallbackNC_RegisterService_requestOrbitData : public Callback_RegisterService_requestOrbitData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RegisterService_requestOrbitData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_requestOrbitData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 */
template<class T> Callback_RegisterService_requestOrbitDataPtr
newCallback_RegisterService_requestOrbitData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestOrbitData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 */
template<class T> Callback_RegisterService_requestOrbitDataPtr
newCallback_RegisterService_requestOrbitData(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestOrbitData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestOrbitData.
 */
template<class T, typename CT>
class Callback_RegisterService_requestOrbitData : public Callback_RegisterService_requestOrbitData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RegisterService_requestOrbitData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_requestOrbitData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 */
template<class T, typename CT> Callback_RegisterService_requestOrbitDataPtr
newCallback_RegisterService_requestOrbitData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestOrbitData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestOrbitData.
 */
template<class T, typename CT> Callback_RegisterService_requestOrbitDataPtr
newCallback_RegisterService_requestOrbitData(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestOrbitData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_getFile.
 */
template<class T>
class CallbackNC_RegisterService_getFile : public Callback_RegisterService_getFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ImageData&);

    CallbackNC_RegisterService_getFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_getFile(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 */
template<class T> Callback_RegisterService_getFilePtr
newCallback_RegisterService_getFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_getFile<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 */
template<class T> Callback_RegisterService_getFilePtr
newCallback_RegisterService_getFile(T* instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_getFile<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_getFile.
 */
template<class T, typename CT>
class Callback_RegisterService_getFile : public Callback_RegisterService_getFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ImageData&, const CT&);

    Callback_RegisterService_getFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_getFile(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 */
template<class T, typename CT> Callback_RegisterService_getFilePtr
newCallback_RegisterService_getFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_getFile<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_getFile.
 */
template<class T, typename CT> Callback_RegisterService_getFilePtr
newCallback_RegisterService_getFile(T* instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_getFile<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestxyzData.
 */
template<class T>
class CallbackNC_RegisterService_requestxyzData : public Callback_RegisterService_requestxyzData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const XYZDATA&);

    CallbackNC_RegisterService_requestxyzData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        XYZDATA ret;
        try
        {
            ret = proxy->end_requestxyzData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 */
template<class T> Callback_RegisterService_requestxyzDataPtr
newCallback_RegisterService_requestxyzData(const IceUtil::Handle<T>& instance, void (T::*cb)(const XYZDATA&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestxyzData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 */
template<class T> Callback_RegisterService_requestxyzDataPtr
newCallback_RegisterService_requestxyzData(T* instance, void (T::*cb)(const XYZDATA&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestxyzData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestxyzData.
 */
template<class T, typename CT>
class Callback_RegisterService_requestxyzData : public Callback_RegisterService_requestxyzData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const XYZDATA&, const CT&);

    Callback_RegisterService_requestxyzData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        XYZDATA ret;
        try
        {
            ret = proxy->end_requestxyzData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 */
template<class T, typename CT> Callback_RegisterService_requestxyzDataPtr
newCallback_RegisterService_requestxyzData(const IceUtil::Handle<T>& instance, void (T::*cb)(const XYZDATA&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestxyzData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestxyzData.
 */
template<class T, typename CT> Callback_RegisterService_requestxyzDataPtr
newCallback_RegisterService_requestxyzData(T* instance, void (T::*cb)(const XYZDATA&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestxyzData<T, CT>(instance, cb, excb, sentcb);
}

}

namespace MPScallMDSService
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushUtcTime.
 */
template<class T>
class CallbackNC_MDSService_pushUtcTime : public Callback_MDSService_pushUtcTime_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushUtcTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushUtcTime.
 */
template<class T, typename CT>
class Callback_MDSService_pushUtcTime : public Callback_MDSService_pushUtcTime_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushUtcTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysOperPara.
 */
template<class T>
class CallbackNC_MDSService_pushSysOperPara : public Callback_MDSService_pushSysOperPara_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushSysOperPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysOperPara.
 */
template<class T, typename CT>
class Callback_MDSService_pushSysOperPara : public Callback_MDSService_pushSysOperPara_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushSysOperPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSatPlatPara.
 */
template<class T>
class CallbackNC_MDSService_pushSatPlatPara : public Callback_MDSService_pushSatPlatPara_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushSatPlatPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSatPlatPara.
 */
template<class T, typename CT>
class Callback_MDSService_pushSatPlatPara : public Callback_MDSService_pushSatPlatPara_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushSatPlatPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskInfo.
 */
template<class T>
class CallbackNC_MDSService_pushTaskInfo : public Callback_MDSService_pushTaskInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushTaskInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskInfo.
 */
template<class T, typename CT>
class Callback_MDSService_pushTaskInfo : public Callback_MDSService_pushTaskInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushTaskInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_imageReady.
 */
template<class T>
class CallbackNC_MDSService_imageReady : public Callback_MDSService_imageReady_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_imageReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_imageReady.
 */
template<class T, typename CT>
class Callback_MDSService_imageReady : public Callback_MDSService_imageReady_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_imageReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushErrorLog.
 */
template<class T>
class CallbackNC_MDSService_pushErrorLog : public Callback_MDSService_pushErrorLog_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushErrorLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushErrorLog.
 */
template<class T, typename CT>
class Callback_MDSService_pushErrorLog : public Callback_MDSService_pushErrorLog_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushErrorLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskStatus.
 */
template<class T>
class CallbackNC_MDSService_pushTaskStatus : public Callback_MDSService_pushTaskStatus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushTaskStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskStatus.
 */
template<class T, typename CT>
class Callback_MDSService_pushTaskStatus : public Callback_MDSService_pushTaskStatus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushTaskStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T, typename CT> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T, typename CT> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T, typename CT> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskStatus.
 */
template<class T, typename CT> Callback_MDSService_pushTaskStatusPtr
newCallback_MDSService_pushTaskStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushOrbitData.
 */
template<class T>
class CallbackNC_MDSService_pushOrbitData : public Callback_MDSService_pushOrbitData_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushOrbitData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushOrbitData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushOrbitData<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushOrbitData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushOrbitData<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushOrbitData.
 */
template<class T, typename CT>
class Callback_MDSService_pushOrbitData : public Callback_MDSService_pushOrbitData_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushOrbitData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T, typename CT> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushOrbitData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T, typename CT> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushOrbitData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T, typename CT> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushOrbitData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushOrbitData.
 */
template<class T, typename CT> Callback_MDSService_pushOrbitDataPtr
newCallback_MDSService_pushOrbitData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushOrbitData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushFFTData.
 */
template<class T>
class CallbackNC_MDSService_pushFFTData : public Callback_MDSService_pushFFTData_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushFFTData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushFFTData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushFFTData<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushFFTData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushFFTData<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushFFTData.
 */
template<class T, typename CT>
class Callback_MDSService_pushFFTData : public Callback_MDSService_pushFFTData_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushFFTData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T, typename CT> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushFFTData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T, typename CT> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushFFTData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T, typename CT> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushFFTData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushFFTData.
 */
template<class T, typename CT> Callback_MDSService_pushFFTDataPtr
newCallback_MDSService_pushFFTData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushFFTData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushPQAData.
 */
template<class T>
class CallbackNC_MDSService_pushPQAData : public Callback_MDSService_pushPQAData_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushPQAData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushPQAData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushPQAData<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushPQAData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushPQAData<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushPQAData.
 */
template<class T, typename CT>
class Callback_MDSService_pushPQAData : public Callback_MDSService_pushPQAData_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushPQAData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T, typename CT> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushPQAData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T, typename CT> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushPQAData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T, typename CT> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushPQAData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushPQAData.
 */
template<class T, typename CT> Callback_MDSService_pushPQADataPtr
newCallback_MDSService_pushPQAData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushPQAData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTime.
 */
template<class T>
class CallbackNC_MDSService_pushTime : public Callback_MDSService_pushTime_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTime<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTime<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTime.
 */
template<class T, typename CT>
class Callback_MDSService_pushTime : public Callback_MDSService_pushTime_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T, typename CT> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T, typename CT> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T, typename CT> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTime.
 */
template<class T, typename CT> Callback_MDSService_pushTimePtr
newCallback_MDSService_pushTime(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysLog.
 */
template<class T>
class CallbackNC_MDSService_pushSysLog : public Callback_MDSService_pushSysLog_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushSysLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysLog<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysLog<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysLog<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysLog<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysLog.
 */
template<class T, typename CT>
class Callback_MDSService_pushSysLog : public Callback_MDSService_pushSysLog_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushSysLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T, typename CT> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysLog<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T, typename CT> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysLog<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T, typename CT> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysLog<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysLog.
 */
template<class T, typename CT> Callback_MDSService_pushSysLogPtr
newCallback_MDSService_pushSysLog(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysLog<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushInstruction.
 */
template<class T>
class CallbackNC_MDSService_pushInstruction : public Callback_MDSService_pushInstruction_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushInstruction(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushInstruction<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushInstruction<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushInstruction<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushInstruction<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushInstruction.
 */
template<class T, typename CT>
class Callback_MDSService_pushInstruction : public Callback_MDSService_pushInstruction_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushInstruction(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T, typename CT> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushInstruction<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T, typename CT> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushInstruction<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T, typename CT> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushInstruction<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushInstruction.
 */
template<class T, typename CT> Callback_MDSService_pushInstructionPtr
newCallback_MDSService_pushInstruction(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushInstruction<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushYaoceyaokongsuju.
 */
template<class T>
class CallbackNC_MDSService_pushYaoceyaokongsuju : public Callback_MDSService_pushYaoceyaokongsuju_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushYaoceyaokongsuju(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushYaoceyaokongsuju<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushYaoceyaokongsuju<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushYaoceyaokongsuju<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushYaoceyaokongsuju<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushYaoceyaokongsuju.
 */
template<class T, typename CT>
class Callback_MDSService_pushYaoceyaokongsuju : public Callback_MDSService_pushYaoceyaokongsuju_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushYaoceyaokongsuju(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T, typename CT> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushYaoceyaokongsuju<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T, typename CT> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushYaoceyaokongsuju<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T, typename CT> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushYaoceyaokongsuju<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushYaoceyaokongsuju.
 */
template<class T, typename CT> Callback_MDSService_pushYaoceyaokongsujuPtr
newCallback_MDSService_pushYaoceyaokongsuju(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushYaoceyaokongsuju<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushProgressAnalysis.
 */
template<class T>
class CallbackNC_MDSService_pushProgressAnalysis : public Callback_MDSService_pushProgressAnalysis_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushProgressAnalysis(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushProgressAnalysis<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushProgressAnalysis<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushProgressAnalysis<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushProgressAnalysis<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushProgressAnalysis.
 */
template<class T, typename CT>
class Callback_MDSService_pushProgressAnalysis : public Callback_MDSService_pushProgressAnalysis_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushProgressAnalysis(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T, typename CT> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushProgressAnalysis<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T, typename CT> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushProgressAnalysis<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T, typename CT> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushProgressAnalysis<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushProgressAnalysis.
 */
template<class T, typename CT> Callback_MDSService_pushProgressAnalysisPtr
newCallback_MDSService_pushProgressAnalysis(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushProgressAnalysis<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
