//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.5
//
// <auto-generated>
//
// Generated from file `MDSmutualMPS.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __MDSmutualMPS_h__
#define __MDSmutualMPS_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 5
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace MDScallMPSService
{

class LoginServiceProxy;
class LoginServiceProxyPrx;
class RegisterService;
class RegisterServicePrx;

}

namespace MPScallMDSService
{

class MDSService;
class MDSServicePrx;

}

namespace MDScallMPSService
{

using ImageData = ::std::vector<::Ice::Byte>;

}

namespace MPScallMDSService
{

struct SysOperPara
{
    int ParamType;
    ::std::string SatID;
    int GIIRSTeleCmdTime;
    int GIIRSTeleCmdPushCycle;
    int AGRITeleCmdPushCycle;
    int AGRITeleCmdTime;
    int RSITeleCmdPushCycle;
    int RSITeleCmdTime;
    ::Ice::Byte GIIRSAMC;
    ::Ice::Byte GIIRSOMC;
    ::Ice::Byte AGRITMC;
    ::Ice::Byte RSIINRFLOW;
    ::Ice::Byte GRIISINRFLOW;
    ::Ice::Byte AGRIAMC;
    ::Ice::Byte AGRIOMC;
    ::Ice::Byte AGRIXINRFLOW;
    ::Ice::Byte GIIRSTMC;
    ::Ice::Byte RSIAMC;
    ::Ice::Byte RSIOMC;
    ::Ice::Byte RSITMC;
    ::Ice::Byte GIIRSNRS;
    ::Ice::Byte AGRINRS;
    ::Ice::Byte RSINRS;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const int&, const int&, const int&, const int&, const int&, const int&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(ParamType, SatID, GIIRSTeleCmdTime, GIIRSTeleCmdPushCycle, AGRITeleCmdPushCycle, AGRITeleCmdTime, RSITeleCmdPushCycle, RSITeleCmdTime, GIIRSAMC, GIIRSOMC, AGRITMC, RSIINRFLOW, GRIISINRFLOW, AGRIAMC, AGRIOMC, AGRIXINRFLOW, GIIRSTMC, RSIAMC, RSIOMC, RSITMC, GIIRSNRS, AGRINRS, RSINRS);
    }
};

struct SatPlatPara
{
    int ParamType;
    ::std::string SatID;
    ::std::string GIIRSTmcTranCh;
    ::std::string AGRITmcTranCh;
    ::std::string FlutterTranCh;
    ::std::string INRDataTranCh;
    ::std::string SatSenserTranCh;
    ::std::string FixedPosRegTranCh;
    ::std::string SEPDataTranCh;
    ::std::string RSIDataTranCh;
    ::std::string AGRIDataTranCh;
    ::std::string GIIRSProDataTranCh;
    ::std::string GIIRSRawDataTranCh;
    ::std::string DataTranRightCh;
    ::std::string DataTranLeftCh;
    ::std::string OrbitConWorkSta;
    ::std::string ImagePositionSta;
    ::std::string SatColScreenFace;
    int NorOrbAngleRange;
    ::std::string FGMWorkStatus;
    ::std::string RADDWorkStatus;
    ::std::string HEPDWorkStatus;
    ::std::string CPDWorkStatus;
    ::std::string RSIWorkStatus;
    ::std::string GIIRSWorkStatus;
    ::std::string AGRIWorkStatus;
    ::std::string SatWorkStatus;
    double OrbitLocation;
    ::std::string RSITmcTranCh;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const double&, const ::std::string&> ice_tuple() const
    {
        return std::tie(ParamType, SatID, GIIRSTmcTranCh, AGRITmcTranCh, FlutterTranCh, INRDataTranCh, SatSenserTranCh, FixedPosRegTranCh, SEPDataTranCh, RSIDataTranCh, AGRIDataTranCh, GIIRSProDataTranCh, GIIRSRawDataTranCh, DataTranRightCh, DataTranLeftCh, OrbitConWorkSta, ImagePositionSta, SatColScreenFace, NorOrbAngleRange, FGMWorkStatus, RADDWorkStatus, HEPDWorkStatus, CPDWorkStatus, RSIWorkStatus, GIIRSWorkStatus, AGRIWorkStatus, SatWorkStatus, OrbitLocation, RSITmcTranCh);
    }
};

struct Task
{
    ::std::string TaskEN;
    ::std::string TaskCN;
    ::std::string TaskCode;
    ::std::string Exdate;
    ::std::string StartTime;
    ::std::string EndTime;
    ::std::string ExStatus;
    ::std::string RealStartTime;
    ::std::string RealEndTime;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(TaskEN, TaskCN, TaskCode, Exdate, StartTime, EndTime, ExStatus, RealStartTime, RealEndTime);
    }
};

using TasksData = ::std::vector<Task>;

using ImageData = ::std::vector<::Ice::Byte>;

struct ErrorLog
{
    ::std::string branchcode;
    ::std::string errorlevel;
    ::std::string status;
    ::std::string time;
    ::std::string taskcode;
    ::std::string message;
    ::std::string errorcode;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(branchcode, errorlevel, status, time, taskcode, message, errorcode);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace MDScallMPSService
{

class LoginServiceProxy : public virtual ::Ice::Object
{
public:

    using ProxyType = LoginServiceProxyPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool LoginAuthentication(::std::string user, ::std::string password, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_LoginAuthentication(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class RegisterService : public virtual ::Ice::Object
{
public:

    using ProxyType = RegisterServicePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool registerModule(::std::string modulename, ::std::string host, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerModule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData requestImage(::std::string branchcode, ::std::string type, int left, int right, int top, int bottom, int width, int height, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_requestImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace MPScallMDSService
{

class MDSService : public virtual ::Ice::Object
{
public:

    using ProxyType = MDSServicePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void pushUtcTime(::std::string time, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushUtcTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSysOperPara(SysOperPara para, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSysOperPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSatPlatPara(SatPlatPara para, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSatPlatPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTaskInfo(::std::string branchCode, TasksData tasks, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTaskInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void imageReady(::std::string type, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_imageReady(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushErrorLog(ErrorLog log, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pushErrorLog(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace MDScallMPSService
{

class LoginServiceProxyPrx : public virtual ::Ice::Proxy<LoginServiceProxyPrx, ::Ice::ObjectPrx>
{
public:

    bool LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LoginServiceProxyPrx::_iceI_LoginAuthentication, user, password, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LoginAuthenticationAsync(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LoginServiceProxyPrx::_iceI_LoginAuthentication, user, password, context);
    }

    ::std::function<void()>
    LoginAuthenticationAsync(const ::std::string& user, const ::std::string& password,
                             ::std::function<void(bool)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::LoginServiceProxyPrx::_iceI_LoginAuthentication, user, password, context);
    }

    /// \cond INTERNAL
    void _iceI_LoginAuthentication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LoginServiceProxyPrx() = default;
    friend ::std::shared_ptr<LoginServiceProxyPrx> IceInternal::createProxy<LoginServiceProxyPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class RegisterServicePrx : public virtual ::Ice::Proxy<RegisterServicePrx, ::Ice::ObjectPrx>
{
public:

    bool registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &RegisterServicePrx::_iceI_registerModule, modulename, host, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerModuleAsync(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &RegisterServicePrx::_iceI_registerModule, modulename, host, context);
    }

    ::std::function<void()>
    registerModuleAsync(const ::std::string& modulename, const ::std::string& host,
                        ::std::function<void(bool)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_registerModule, modulename, host, context);
    }

    /// \cond INTERNAL
    void _iceI_registerModule(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ImageData requestImage(const ::std::string& branchcode, const ::std::string& type, int left, int right, int top, int bottom, int width, int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData>(true, this, &RegisterServicePrx::_iceI_requestImage, branchcode, type, left, right, top, bottom, width, height, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto requestImageAsync(const ::std::string& branchcode, const ::std::string& type, int left, int right, int top, int bottom, int width, int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MDScallMPSService::ImageData>>().get_future())
    {
        return _makePromiseOutgoing<::MDScallMPSService::ImageData, P>(false, this, &RegisterServicePrx::_iceI_requestImage, branchcode, type, left, right, top, bottom, width, height, context);
    }

    ::std::function<void()>
    requestImageAsync(const ::std::string& branchcode, const ::std::string& type, int left, int right, int top, int bottom, int width, int height,
                      ::std::function<void(::MDScallMPSService::ImageData)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MDScallMPSService::ImageData>(std::move(response), std::move(ex), std::move(sent), this, &MDScallMPSService::RegisterServicePrx::_iceI_requestImage, branchcode, type, left, right, top, bottom, width, height, context);
    }

    /// \cond INTERNAL
    void _iceI_requestImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MDScallMPSService::ImageData>>&, const ::std::string&, const ::std::string&, int, int, int, int, int, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    RegisterServicePrx() = default;
    friend ::std::shared_ptr<RegisterServicePrx> IceInternal::createProxy<RegisterServicePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

namespace MPScallMDSService
{

class MDSServicePrx : public virtual ::Ice::Proxy<MDSServicePrx, ::Ice::ObjectPrx>
{
public:

    void pushUtcTime(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushUtcTime, time, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushUtcTimeAsync(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushUtcTime, time, context);
    }

    ::std::function<void()>
    pushUtcTimeAsync(const ::std::string& time,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushUtcTime, time, context);
    }

    /// \cond INTERNAL
    void _iceI_pushUtcTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void pushSysOperPara(const SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushSysOperPara, para, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushSysOperParaAsync(const SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushSysOperPara, para, context);
    }

    ::std::function<void()>
    pushSysOperParaAsync(const SysOperPara& para,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushSysOperPara, para, context);
    }

    /// \cond INTERNAL
    void _iceI_pushSysOperPara(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const SysOperPara&, const ::Ice::Context&);
    /// \endcond

    void pushSatPlatPara(const SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushSatPlatPara, para, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushSatPlatParaAsync(const SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushSatPlatPara, para, context);
    }

    ::std::function<void()>
    pushSatPlatParaAsync(const SatPlatPara& para,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushSatPlatPara, para, context);
    }

    /// \cond INTERNAL
    void _iceI_pushSatPlatPara(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const SatPlatPara&, const ::Ice::Context&);
    /// \endcond

    void pushTaskInfo(const ::std::string& branchCode, const TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushTaskInfo, branchCode, tasks, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushTaskInfoAsync(const ::std::string& branchCode, const TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushTaskInfo, branchCode, tasks, context);
    }

    ::std::function<void()>
    pushTaskInfoAsync(const ::std::string& branchCode, const TasksData& tasks,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushTaskInfo, branchCode, tasks, context);
    }

    /// \cond INTERNAL
    void _iceI_pushTaskInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const TasksData&, const ::Ice::Context&);
    /// \endcond

    void imageReady(const ::std::string& type, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_imageReady, type, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto imageReadyAsync(const ::std::string& type, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_imageReady, type, context);
    }

    ::std::function<void()>
    imageReadyAsync(const ::std::string& type,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_imageReady, type, context);
    }

    /// \cond INTERNAL
    void _iceI_imageReady(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void pushErrorLog(const ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MDSServicePrx::_iceI_pushErrorLog, log, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pushErrorLogAsync(const ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MDSServicePrx::_iceI_pushErrorLog, log, context);
    }

    ::std::function<void()>
    pushErrorLogAsync(const ErrorLog& log,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPScallMDSService::MDSServicePrx::_iceI_pushErrorLog, log, context);
    }

    /// \cond INTERNAL
    void _iceI_pushErrorLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ErrorLog&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MDSServicePrx() = default;
    friend ::std::shared_ptr<MDSServicePrx> IceInternal::createProxy<MDSServicePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::MPScallMDSService::SysOperPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 44;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::SysOperPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SysOperPara& v)
    {
        istr->readAll(v.ParamType, v.SatID, v.GIIRSTeleCmdTime, v.GIIRSTeleCmdPushCycle, v.AGRITeleCmdPushCycle, v.AGRITeleCmdTime, v.RSITeleCmdPushCycle, v.RSITeleCmdTime, v.GIIRSAMC, v.GIIRSOMC, v.AGRITMC, v.RSIINRFLOW, v.GRIISINRFLOW, v.AGRIAMC, v.AGRIOMC, v.AGRIXINRFLOW, v.GIIRSTMC, v.RSIAMC, v.RSIOMC, v.RSITMC, v.GIIRSNRS, v.AGRINRS, v.RSINRS);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::SatPlatPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 42;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::SatPlatPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SatPlatPara& v)
    {
        istr->readAll(v.ParamType, v.SatID, v.GIIRSTmcTranCh, v.AGRITmcTranCh, v.FlutterTranCh, v.INRDataTranCh, v.SatSenserTranCh, v.FixedPosRegTranCh, v.SEPDataTranCh, v.RSIDataTranCh, v.AGRIDataTranCh, v.GIIRSProDataTranCh, v.GIIRSRawDataTranCh, v.DataTranRightCh, v.DataTranLeftCh, v.OrbitConWorkSta, v.ImagePositionSta, v.SatColScreenFace, v.NorOrbAngleRange, v.FGMWorkStatus, v.RADDWorkStatus, v.HEPDWorkStatus, v.CPDWorkStatus, v.RSIWorkStatus, v.GIIRSWorkStatus, v.AGRIWorkStatus, v.SatWorkStatus, v.OrbitLocation, v.RSITmcTranCh);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::Task>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::Task, S>
{
    static void read(S* istr, ::MPScallMDSService::Task& v)
    {
        istr->readAll(v.TaskEN, v.TaskCN, v.TaskCode, v.Exdate, v.StartTime, v.EndTime, v.ExStatus, v.RealStartTime, v.RealEndTime);
    }
};

template<>
struct StreamableTraits<::MPScallMDSService::ErrorLog>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPScallMDSService::ErrorLog, S>
{
    static void read(S* istr, ::MPScallMDSService::ErrorLog& v)
    {
        istr->readAll(v.branchcode, v.errorlevel, v.status, v.time, v.taskcode, v.message, v.errorcode);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace MDScallMPSService
{

using LoginServiceProxyPtr = ::std::shared_ptr<LoginServiceProxy>;
using LoginServiceProxyPrxPtr = ::std::shared_ptr<LoginServiceProxyPrx>;

using RegisterServicePtr = ::std::shared_ptr<RegisterService>;
using RegisterServicePrxPtr = ::std::shared_ptr<RegisterServicePrx>;

}
/// \endcond

/// \cond INTERNAL
namespace MPScallMDSService
{

using MDSServicePtr = ::std::shared_ptr<MDSService>;
using MDSServicePrxPtr = ::std::shared_ptr<MDSServicePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace MDScallMPSService
{

class LoginServiceProxy;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LoginServiceProxy>&);
::IceProxy::Ice::Object* upCast(LoginServiceProxy*);
/// \endcond

class RegisterService;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< RegisterService>&);
::IceProxy::Ice::Object* upCast(RegisterService*);
/// \endcond

}

namespace MPScallMDSService
{

class MDSService;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MDSService>&);
::IceProxy::Ice::Object* upCast(MDSService*);
/// \endcond

}

}

namespace MDScallMPSService
{

class LoginServiceProxy;
/// \cond INTERNAL
::Ice::Object* upCast(LoginServiceProxy*);
/// \endcond
typedef ::IceInternal::Handle< LoginServiceProxy> LoginServiceProxyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MDScallMPSService::LoginServiceProxy> LoginServiceProxyPrx;
typedef LoginServiceProxyPrx LoginServiceProxyPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LoginServiceProxyPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class RegisterService;
/// \cond INTERNAL
::Ice::Object* upCast(RegisterService*);
/// \endcond
typedef ::IceInternal::Handle< RegisterService> RegisterServicePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MDScallMPSService::RegisterService> RegisterServicePrx;
typedef RegisterServicePrx RegisterServicePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RegisterServicePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace MPScallMDSService
{

class MDSService;
/// \cond INTERNAL
::Ice::Object* upCast(MDSService*);
/// \endcond
typedef ::IceInternal::Handle< MDSService> MDSServicePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPScallMDSService::MDSService> MDSServicePrx;
typedef MDSServicePrx MDSServicePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MDSServicePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace MDScallMPSService
{

typedef ::std::vector< ::Ice::Byte> ImageData;

}

namespace MPScallMDSService
{

struct SysOperPara
{
    ::Ice::Int ParamType;
    ::std::string SatID;
    ::Ice::Int GIIRSTeleCmdTime;
    ::Ice::Int GIIRSTeleCmdPushCycle;
    ::Ice::Int AGRITeleCmdPushCycle;
    ::Ice::Int AGRITeleCmdTime;
    ::Ice::Int RSITeleCmdPushCycle;
    ::Ice::Int RSITeleCmdTime;
    ::Ice::Byte GIIRSAMC;
    ::Ice::Byte GIIRSOMC;
    ::Ice::Byte AGRITMC;
    ::Ice::Byte RSIINRFLOW;
    ::Ice::Byte GRIISINRFLOW;
    ::Ice::Byte AGRIAMC;
    ::Ice::Byte AGRIOMC;
    ::Ice::Byte AGRIXINRFLOW;
    ::Ice::Byte GIIRSTMC;
    ::Ice::Byte RSIAMC;
    ::Ice::Byte RSIOMC;
    ::Ice::Byte RSITMC;
    ::Ice::Byte GIIRSNRS;
    ::Ice::Byte AGRINRS;
    ::Ice::Byte RSINRS;

    bool operator==(const SysOperPara& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(ParamType != rhs_.ParamType)
        {
            return false;
        }
        if(SatID != rhs_.SatID)
        {
            return false;
        }
        if(GIIRSTeleCmdTime != rhs_.GIIRSTeleCmdTime)
        {
            return false;
        }
        if(GIIRSTeleCmdPushCycle != rhs_.GIIRSTeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdPushCycle != rhs_.AGRITeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdTime != rhs_.AGRITeleCmdTime)
        {
            return false;
        }
        if(RSITeleCmdPushCycle != rhs_.RSITeleCmdPushCycle)
        {
            return false;
        }
        if(RSITeleCmdTime != rhs_.RSITeleCmdTime)
        {
            return false;
        }
        if(GIIRSAMC != rhs_.GIIRSAMC)
        {
            return false;
        }
        if(GIIRSOMC != rhs_.GIIRSOMC)
        {
            return false;
        }
        if(AGRITMC != rhs_.AGRITMC)
        {
            return false;
        }
        if(RSIINRFLOW != rhs_.RSIINRFLOW)
        {
            return false;
        }
        if(GRIISINRFLOW != rhs_.GRIISINRFLOW)
        {
            return false;
        }
        if(AGRIAMC != rhs_.AGRIAMC)
        {
            return false;
        }
        if(AGRIOMC != rhs_.AGRIOMC)
        {
            return false;
        }
        if(AGRIXINRFLOW != rhs_.AGRIXINRFLOW)
        {
            return false;
        }
        if(GIIRSTMC != rhs_.GIIRSTMC)
        {
            return false;
        }
        if(RSIAMC != rhs_.RSIAMC)
        {
            return false;
        }
        if(RSIOMC != rhs_.RSIOMC)
        {
            return false;
        }
        if(RSITMC != rhs_.RSITMC)
        {
            return false;
        }
        if(GIIRSNRS != rhs_.GIIRSNRS)
        {
            return false;
        }
        if(AGRINRS != rhs_.AGRINRS)
        {
            return false;
        }
        if(RSINRS != rhs_.RSINRS)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SysOperPara& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(ParamType < rhs_.ParamType)
        {
            return true;
        }
        else if(rhs_.ParamType < ParamType)
        {
            return false;
        }
        if(SatID < rhs_.SatID)
        {
            return true;
        }
        else if(rhs_.SatID < SatID)
        {
            return false;
        }
        if(GIIRSTeleCmdTime < rhs_.GIIRSTeleCmdTime)
        {
            return true;
        }
        else if(rhs_.GIIRSTeleCmdTime < GIIRSTeleCmdTime)
        {
            return false;
        }
        if(GIIRSTeleCmdPushCycle < rhs_.GIIRSTeleCmdPushCycle)
        {
            return true;
        }
        else if(rhs_.GIIRSTeleCmdPushCycle < GIIRSTeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdPushCycle < rhs_.AGRITeleCmdPushCycle)
        {
            return true;
        }
        else if(rhs_.AGRITeleCmdPushCycle < AGRITeleCmdPushCycle)
        {
            return false;
        }
        if(AGRITeleCmdTime < rhs_.AGRITeleCmdTime)
        {
            return true;
        }
        else if(rhs_.AGRITeleCmdTime < AGRITeleCmdTime)
        {
            return false;
        }
        if(RSITeleCmdPushCycle < rhs_.RSITeleCmdPushCycle)
        {
            return true;
        }
        else if(rhs_.RSITeleCmdPushCycle < RSITeleCmdPushCycle)
        {
            return false;
        }
        if(RSITeleCmdTime < rhs_.RSITeleCmdTime)
        {
            return true;
        }
        else if(rhs_.RSITeleCmdTime < RSITeleCmdTime)
        {
            return false;
        }
        if(GIIRSAMC < rhs_.GIIRSAMC)
        {
            return true;
        }
        else if(rhs_.GIIRSAMC < GIIRSAMC)
        {
            return false;
        }
        if(GIIRSOMC < rhs_.GIIRSOMC)
        {
            return true;
        }
        else if(rhs_.GIIRSOMC < GIIRSOMC)
        {
            return false;
        }
        if(AGRITMC < rhs_.AGRITMC)
        {
            return true;
        }
        else if(rhs_.AGRITMC < AGRITMC)
        {
            return false;
        }
        if(RSIINRFLOW < rhs_.RSIINRFLOW)
        {
            return true;
        }
        else if(rhs_.RSIINRFLOW < RSIINRFLOW)
        {
            return false;
        }
        if(GRIISINRFLOW < rhs_.GRIISINRFLOW)
        {
            return true;
        }
        else if(rhs_.GRIISINRFLOW < GRIISINRFLOW)
        {
            return false;
        }
        if(AGRIAMC < rhs_.AGRIAMC)
        {
            return true;
        }
        else if(rhs_.AGRIAMC < AGRIAMC)
        {
            return false;
        }
        if(AGRIOMC < rhs_.AGRIOMC)
        {
            return true;
        }
        else if(rhs_.AGRIOMC < AGRIOMC)
        {
            return false;
        }
        if(AGRIXINRFLOW < rhs_.AGRIXINRFLOW)
        {
            return true;
        }
        else if(rhs_.AGRIXINRFLOW < AGRIXINRFLOW)
        {
            return false;
        }
        if(GIIRSTMC < rhs_.GIIRSTMC)
        {
            return true;
        }
        else if(rhs_.GIIRSTMC < GIIRSTMC)
        {
            return false;
        }
        if(RSIAMC < rhs_.RSIAMC)
        {
            return true;
        }
        else if(rhs_.RSIAMC < RSIAMC)
        {
            return false;
        }
        if(RSIOMC < rhs_.RSIOMC)
        {
            return true;
        }
        else if(rhs_.RSIOMC < RSIOMC)
        {
            return false;
        }
        if(RSITMC < rhs_.RSITMC)
        {
            return true;
        }
        else if(rhs_.RSITMC < RSITMC)
        {
            return false;
        }
        if(GIIRSNRS < rhs_.GIIRSNRS)
        {
            return true;
        }
        else if(rhs_.GIIRSNRS < GIIRSNRS)
        {
            return false;
        }
        if(AGRINRS < rhs_.AGRINRS)
        {
            return true;
        }
        else if(rhs_.AGRINRS < AGRINRS)
        {
            return false;
        }
        if(RSINRS < rhs_.RSINRS)
        {
            return true;
        }
        else if(rhs_.RSINRS < RSINRS)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SysOperPara& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SysOperPara& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SysOperPara& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SysOperPara& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct SatPlatPara
{
    ::Ice::Int ParamType;
    ::std::string SatID;
    ::std::string GIIRSTmcTranCh;
    ::std::string AGRITmcTranCh;
    ::std::string FlutterTranCh;
    ::std::string INRDataTranCh;
    ::std::string SatSenserTranCh;
    ::std::string FixedPosRegTranCh;
    ::std::string SEPDataTranCh;
    ::std::string RSIDataTranCh;
    ::std::string AGRIDataTranCh;
    ::std::string GIIRSProDataTranCh;
    ::std::string GIIRSRawDataTranCh;
    ::std::string DataTranRightCh;
    ::std::string DataTranLeftCh;
    ::std::string OrbitConWorkSta;
    ::std::string ImagePositionSta;
    ::std::string SatColScreenFace;
    ::Ice::Int NorOrbAngleRange;
    ::std::string FGMWorkStatus;
    ::std::string RADDWorkStatus;
    ::std::string HEPDWorkStatus;
    ::std::string CPDWorkStatus;
    ::std::string RSIWorkStatus;
    ::std::string GIIRSWorkStatus;
    ::std::string AGRIWorkStatus;
    ::std::string SatWorkStatus;
    ::Ice::Double OrbitLocation;
    ::std::string RSITmcTranCh;
};

struct Task
{
    ::std::string TaskEN;
    ::std::string TaskCN;
    ::std::string TaskCode;
    ::std::string Exdate;
    ::std::string StartTime;
    ::std::string EndTime;
    ::std::string ExStatus;
    ::std::string RealStartTime;
    ::std::string RealEndTime;

    bool operator==(const Task& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(TaskEN != rhs_.TaskEN)
        {
            return false;
        }
        if(TaskCN != rhs_.TaskCN)
        {
            return false;
        }
        if(TaskCode != rhs_.TaskCode)
        {
            return false;
        }
        if(Exdate != rhs_.Exdate)
        {
            return false;
        }
        if(StartTime != rhs_.StartTime)
        {
            return false;
        }
        if(EndTime != rhs_.EndTime)
        {
            return false;
        }
        if(ExStatus != rhs_.ExStatus)
        {
            return false;
        }
        if(RealStartTime != rhs_.RealStartTime)
        {
            return false;
        }
        if(RealEndTime != rhs_.RealEndTime)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Task& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(TaskEN < rhs_.TaskEN)
        {
            return true;
        }
        else if(rhs_.TaskEN < TaskEN)
        {
            return false;
        }
        if(TaskCN < rhs_.TaskCN)
        {
            return true;
        }
        else if(rhs_.TaskCN < TaskCN)
        {
            return false;
        }
        if(TaskCode < rhs_.TaskCode)
        {
            return true;
        }
        else if(rhs_.TaskCode < TaskCode)
        {
            return false;
        }
        if(Exdate < rhs_.Exdate)
        {
            return true;
        }
        else if(rhs_.Exdate < Exdate)
        {
            return false;
        }
        if(StartTime < rhs_.StartTime)
        {
            return true;
        }
        else if(rhs_.StartTime < StartTime)
        {
            return false;
        }
        if(EndTime < rhs_.EndTime)
        {
            return true;
        }
        else if(rhs_.EndTime < EndTime)
        {
            return false;
        }
        if(ExStatus < rhs_.ExStatus)
        {
            return true;
        }
        else if(rhs_.ExStatus < ExStatus)
        {
            return false;
        }
        if(RealStartTime < rhs_.RealStartTime)
        {
            return true;
        }
        else if(rhs_.RealStartTime < RealStartTime)
        {
            return false;
        }
        if(RealEndTime < rhs_.RealEndTime)
        {
            return true;
        }
        else if(rhs_.RealEndTime < RealEndTime)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Task& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Task& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Task& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Task& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Task> TasksData;

typedef ::std::vector< ::Ice::Byte> ImageData;

struct ErrorLog
{
    ::std::string branchcode;
    ::std::string errorlevel;
    ::std::string status;
    ::std::string time;
    ::std::string taskcode;
    ::std::string message;
    ::std::string errorcode;

    bool operator==(const ErrorLog& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(branchcode != rhs_.branchcode)
        {
            return false;
        }
        if(errorlevel != rhs_.errorlevel)
        {
            return false;
        }
        if(status != rhs_.status)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(taskcode != rhs_.taskcode)
        {
            return false;
        }
        if(message != rhs_.message)
        {
            return false;
        }
        if(errorcode != rhs_.errorcode)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ErrorLog& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(branchcode < rhs_.branchcode)
        {
            return true;
        }
        else if(rhs_.branchcode < branchcode)
        {
            return false;
        }
        if(errorlevel < rhs_.errorlevel)
        {
            return true;
        }
        else if(rhs_.errorlevel < errorlevel)
        {
            return false;
        }
        if(status < rhs_.status)
        {
            return true;
        }
        else if(rhs_.status < status)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(taskcode < rhs_.taskcode)
        {
            return true;
        }
        else if(rhs_.taskcode < taskcode)
        {
            return false;
        }
        if(message < rhs_.message)
        {
            return true;
        }
        else if(rhs_.message < message)
        {
            return false;
        }
        if(errorcode < rhs_.errorcode)
        {
            return true;
        }
        else if(rhs_.errorcode < errorcode)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ErrorLog& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ErrorLog& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ErrorLog& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ErrorLog& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace MDScallMPSService
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_LoginServiceProxy_LoginAuthentication.
 */
class Callback_LoginServiceProxy_LoginAuthentication_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LoginServiceProxy_LoginAuthentication_Base> Callback_LoginServiceProxy_LoginAuthenticationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_registerModule.
 */
class Callback_RegisterService_registerModule_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_registerModule_Base> Callback_RegisterService_registerModulePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestImage.
 */
class Callback_RegisterService_requestImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RegisterService_requestImage_Base> Callback_RegisterService_requestImagePtr;

}

namespace MPScallMDSService
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushUtcTime.
 */
class Callback_MDSService_pushUtcTime_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushUtcTime_Base> Callback_MDSService_pushUtcTimePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysOperPara.
 */
class Callback_MDSService_pushSysOperPara_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushSysOperPara_Base> Callback_MDSService_pushSysOperParaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSatPlatPara.
 */
class Callback_MDSService_pushSatPlatPara_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushSatPlatPara_Base> Callback_MDSService_pushSatPlatParaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskInfo.
 */
class Callback_MDSService_pushTaskInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushTaskInfo_Base> Callback_MDSService_pushTaskInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_imageReady.
 */
class Callback_MDSService_imageReady_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_imageReady_Base> Callback_MDSService_imageReadyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushErrorLog.
 */
class Callback_MDSService_pushErrorLog_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MDSService_pushErrorLog_Base> Callback_MDSService_pushErrorLogPtr;

}

namespace IceProxy
{

namespace MDScallMPSService
{

class LoginServiceProxy : public virtual ::Ice::Proxy<LoginServiceProxy, ::IceProxy::Ice::Object>
{
public:

    bool LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_LoginAuthentication(_iceI_begin_LoginAuthentication(user, password, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LoginAuthentication(user, password, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::MDScallMPSService::Callback_LoginServiceProxy_LoginAuthenticationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Context& context, const ::MDScallMPSService::Callback_LoginServiceProxy_LoginAuthenticationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LoginAuthentication(user, password, context, cb, cookie);
    }

    bool end_LoginAuthentication(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LoginAuthentication(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class RegisterService : public virtual ::Ice::Proxy<RegisterService, ::IceProxy::Ice::Object>
{
public:

    bool registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerModule(_iceI_begin_registerModule(modulename, host, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerModule(modulename, host, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::MDScallMPSService::Callback_RegisterService_registerModulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_registerModulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerModule(modulename, host, context, cb, cookie);
    }

    bool end_registerModule(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerModule(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MDScallMPSService::ImageData requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_requestImage(_iceI_begin_requestImage(branchcode, type, left, right, top, bottom, width, height, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_requestImage(branchcode, type, left, right, top, bottom, width, height, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(branchcode, type, left, right, top, bottom, width, height, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(branchcode, type, left, right, top, bottom, width, height, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::MDScallMPSService::Callback_RegisterService_requestImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(branchcode, type, left, right, top, bottom, width, height, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Context& context, const ::MDScallMPSService::Callback_RegisterService_requestImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_requestImage(branchcode, type, left, right, top, bottom, width, height, context, cb, cookie);
    }

    ::MDScallMPSService::ImageData end_requestImage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_requestImage(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace MPScallMDSService
{

class MDSService : public virtual ::Ice::Proxy<MDSService, ::IceProxy::Ice::Object>
{
public:

    void pushUtcTime(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushUtcTime(_iceI_begin_pushUtcTime(time, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushUtcTime(time, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::MPScallMDSService::Callback_MDSService_pushUtcTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushUtcTime(const ::std::string& time, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushUtcTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushUtcTime(time, context, cb, cookie);
    }

    void end_pushUtcTime(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushUtcTime(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushSysOperPara(_iceI_begin_pushSysOperPara(para, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushSysOperPara(para, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::MPScallMDSService::Callback_MDSService_pushSysOperParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara& para, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushSysOperParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSysOperPara(para, context, cb, cookie);
    }

    void end_pushSysOperPara(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushSysOperPara(const ::MPScallMDSService::SysOperPara&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushSatPlatPara(_iceI_begin_pushSatPlatPara(para, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushSatPlatPara(para, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::MPScallMDSService::Callback_MDSService_pushSatPlatParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara& para, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushSatPlatParaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushSatPlatPara(para, context, cb, cookie);
    }

    void end_pushSatPlatPara(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushSatPlatPara(const ::MPScallMDSService::SatPlatPara&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushTaskInfo(_iceI_begin_pushTaskInfo(branchCode, tasks, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::MPScallMDSService::Callback_MDSService_pushTaskInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushTaskInfo(const ::std::string& branchCode, const ::MPScallMDSService::TasksData& tasks, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushTaskInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushTaskInfo(branchCode, tasks, context, cb, cookie);
    }

    void end_pushTaskInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushTaskInfo(const ::std::string&, const ::MPScallMDSService::TasksData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void imageReady(const ::std::string& type, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_imageReady(_iceI_begin_imageReady(type, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_imageReady(type, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::MPScallMDSService::Callback_MDSService_imageReadyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_imageReady(const ::std::string& type, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_imageReadyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_imageReady(type, context, cb, cookie);
    }

    void end_imageReady(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_imageReady(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pushErrorLog(_iceI_begin_pushErrorLog(log, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pushErrorLog(log, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::MPScallMDSService::Callback_MDSService_pushErrorLogPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pushErrorLog(const ::MPScallMDSService::ErrorLog& log, const ::Ice::Context& context, const ::MPScallMDSService::Callback_MDSService_pushErrorLogPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pushErrorLog(log, context, cb, cookie);
    }

    void end_pushErrorLog(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pushErrorLog(const ::MPScallMDSService::ErrorLog&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace MDScallMPSService
{

class LoginServiceProxy : public virtual ::Ice::Object
{
public:

    typedef LoginServiceProxyPrx ProxyType;
    typedef LoginServiceProxyPtr PointerType;

    virtual ~LoginServiceProxy();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool LoginAuthentication(const ::std::string& user, const ::std::string& password, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_LoginAuthentication(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const LoginServiceProxy& lhs, const LoginServiceProxy& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LoginServiceProxy& lhs, const LoginServiceProxy& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class RegisterService : public virtual ::Ice::Object
{
public:

    typedef RegisterServicePrx ProxyType;
    typedef RegisterServicePtr PointerType;

    virtual ~RegisterService();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool registerModule(const ::std::string& modulename, const ::std::string& host, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerModule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImageData requestImage(const ::std::string& branchcode, const ::std::string& type, ::Ice::Int left, ::Ice::Int right, ::Ice::Int top, ::Ice::Int bottom, ::Ice::Int width, ::Ice::Int height, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_requestImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const RegisterService& lhs, const RegisterService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const RegisterService& lhs, const RegisterService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace MPScallMDSService
{

class MDSService : public virtual ::Ice::Object
{
public:

    typedef MDSServicePrx ProxyType;
    typedef MDSServicePtr PointerType;

    virtual ~MDSService();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void pushUtcTime(const ::std::string& time, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushUtcTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSysOperPara(const SysOperPara& para, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSysOperPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushSatPlatPara(const SatPlatPara& para, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushSatPlatPara(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushTaskInfo(const ::std::string& branchCode, const TasksData& tasks, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushTaskInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void imageReady(const ::std::string& type, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_imageReady(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pushErrorLog(const ErrorLog& log, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pushErrorLog(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MDSService& lhs, const MDSService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MDSService& lhs, const MDSService& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::MPScallMDSService::SysOperPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 44;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::SysOperPara, S>
{
    static void write(S* ostr, const ::MPScallMDSService::SysOperPara& v)
    {
        ostr->write(v.ParamType);
        ostr->write(v.SatID);
        ostr->write(v.GIIRSTeleCmdTime);
        ostr->write(v.GIIRSTeleCmdPushCycle);
        ostr->write(v.AGRITeleCmdPushCycle);
        ostr->write(v.AGRITeleCmdTime);
        ostr->write(v.RSITeleCmdPushCycle);
        ostr->write(v.RSITeleCmdTime);
        ostr->write(v.GIIRSAMC);
        ostr->write(v.GIIRSOMC);
        ostr->write(v.AGRITMC);
        ostr->write(v.RSIINRFLOW);
        ostr->write(v.GRIISINRFLOW);
        ostr->write(v.AGRIAMC);
        ostr->write(v.AGRIOMC);
        ostr->write(v.AGRIXINRFLOW);
        ostr->write(v.GIIRSTMC);
        ostr->write(v.RSIAMC);
        ostr->write(v.RSIOMC);
        ostr->write(v.RSITMC);
        ostr->write(v.GIIRSNRS);
        ostr->write(v.AGRINRS);
        ostr->write(v.RSINRS);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::SysOperPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SysOperPara& v)
    {
        istr->read(v.ParamType);
        istr->read(v.SatID);
        istr->read(v.GIIRSTeleCmdTime);
        istr->read(v.GIIRSTeleCmdPushCycle);
        istr->read(v.AGRITeleCmdPushCycle);
        istr->read(v.AGRITeleCmdTime);
        istr->read(v.RSITeleCmdPushCycle);
        istr->read(v.RSITeleCmdTime);
        istr->read(v.GIIRSAMC);
        istr->read(v.GIIRSOMC);
        istr->read(v.AGRITMC);
        istr->read(v.RSIINRFLOW);
        istr->read(v.GRIISINRFLOW);
        istr->read(v.AGRIAMC);
        istr->read(v.AGRIOMC);
        istr->read(v.AGRIXINRFLOW);
        istr->read(v.GIIRSTMC);
        istr->read(v.RSIAMC);
        istr->read(v.RSIOMC);
        istr->read(v.RSITMC);
        istr->read(v.GIIRSNRS);
        istr->read(v.AGRINRS);
        istr->read(v.RSINRS);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::SatPlatPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 42;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::SatPlatPara, S>
{
    static void write(S* ostr, const ::MPScallMDSService::SatPlatPara& v)
    {
        ostr->write(v.ParamType);
        ostr->write(v.SatID);
        ostr->write(v.GIIRSTmcTranCh);
        ostr->write(v.AGRITmcTranCh);
        ostr->write(v.FlutterTranCh);
        ostr->write(v.INRDataTranCh);
        ostr->write(v.SatSenserTranCh);
        ostr->write(v.FixedPosRegTranCh);
        ostr->write(v.SEPDataTranCh);
        ostr->write(v.RSIDataTranCh);
        ostr->write(v.AGRIDataTranCh);
        ostr->write(v.GIIRSProDataTranCh);
        ostr->write(v.GIIRSRawDataTranCh);
        ostr->write(v.DataTranRightCh);
        ostr->write(v.DataTranLeftCh);
        ostr->write(v.OrbitConWorkSta);
        ostr->write(v.ImagePositionSta);
        ostr->write(v.SatColScreenFace);
        ostr->write(v.NorOrbAngleRange);
        ostr->write(v.FGMWorkStatus);
        ostr->write(v.RADDWorkStatus);
        ostr->write(v.HEPDWorkStatus);
        ostr->write(v.CPDWorkStatus);
        ostr->write(v.RSIWorkStatus);
        ostr->write(v.GIIRSWorkStatus);
        ostr->write(v.AGRIWorkStatus);
        ostr->write(v.SatWorkStatus);
        ostr->write(v.OrbitLocation);
        ostr->write(v.RSITmcTranCh);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::SatPlatPara, S>
{
    static void read(S* istr, ::MPScallMDSService::SatPlatPara& v)
    {
        istr->read(v.ParamType);
        istr->read(v.SatID);
        istr->read(v.GIIRSTmcTranCh);
        istr->read(v.AGRITmcTranCh);
        istr->read(v.FlutterTranCh);
        istr->read(v.INRDataTranCh);
        istr->read(v.SatSenserTranCh);
        istr->read(v.FixedPosRegTranCh);
        istr->read(v.SEPDataTranCh);
        istr->read(v.RSIDataTranCh);
        istr->read(v.AGRIDataTranCh);
        istr->read(v.GIIRSProDataTranCh);
        istr->read(v.GIIRSRawDataTranCh);
        istr->read(v.DataTranRightCh);
        istr->read(v.DataTranLeftCh);
        istr->read(v.OrbitConWorkSta);
        istr->read(v.ImagePositionSta);
        istr->read(v.SatColScreenFace);
        istr->read(v.NorOrbAngleRange);
        istr->read(v.FGMWorkStatus);
        istr->read(v.RADDWorkStatus);
        istr->read(v.HEPDWorkStatus);
        istr->read(v.CPDWorkStatus);
        istr->read(v.RSIWorkStatus);
        istr->read(v.GIIRSWorkStatus);
        istr->read(v.AGRIWorkStatus);
        istr->read(v.SatWorkStatus);
        istr->read(v.OrbitLocation);
        istr->read(v.RSITmcTranCh);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::Task>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::Task, S>
{
    static void write(S* ostr, const ::MPScallMDSService::Task& v)
    {
        ostr->write(v.TaskEN);
        ostr->write(v.TaskCN);
        ostr->write(v.TaskCode);
        ostr->write(v.Exdate);
        ostr->write(v.StartTime);
        ostr->write(v.EndTime);
        ostr->write(v.ExStatus);
        ostr->write(v.RealStartTime);
        ostr->write(v.RealEndTime);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::Task, S>
{
    static void read(S* istr, ::MPScallMDSService::Task& v)
    {
        istr->read(v.TaskEN);
        istr->read(v.TaskCN);
        istr->read(v.TaskCode);
        istr->read(v.Exdate);
        istr->read(v.StartTime);
        istr->read(v.EndTime);
        istr->read(v.ExStatus);
        istr->read(v.RealStartTime);
        istr->read(v.RealEndTime);
    }
};

template<>
struct StreamableTraits< ::MPScallMDSService::ErrorLog>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPScallMDSService::ErrorLog, S>
{
    static void write(S* ostr, const ::MPScallMDSService::ErrorLog& v)
    {
        ostr->write(v.branchcode);
        ostr->write(v.errorlevel);
        ostr->write(v.status);
        ostr->write(v.time);
        ostr->write(v.taskcode);
        ostr->write(v.message);
        ostr->write(v.errorcode);
    }
};

template<typename S>
struct StreamReader< ::MPScallMDSService::ErrorLog, S>
{
    static void read(S* istr, ::MPScallMDSService::ErrorLog& v)
    {
        istr->read(v.branchcode);
        istr->read(v.errorlevel);
        istr->read(v.status);
        istr->read(v.time);
        istr->read(v.taskcode);
        istr->read(v.message);
        istr->read(v.errorcode);
    }
};

}
/// \endcond

namespace MDScallMPSService
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_LoginServiceProxy_LoginAuthentication.
 */
template<class T>
class CallbackNC_LoginServiceProxy_LoginAuthentication : public Callback_LoginServiceProxy_LoginAuthentication_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LoginServiceProxy_LoginAuthentication(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LoginServiceProxyPrx proxy = LoginServiceProxyPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LoginAuthentication(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LoginServiceProxy_LoginAuthentication<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LoginServiceProxy_LoginAuthentication<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_LoginServiceProxy_LoginAuthentication.
 */
template<class T, typename CT>
class Callback_LoginServiceProxy_LoginAuthentication : public Callback_LoginServiceProxy_LoginAuthentication_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LoginServiceProxy_LoginAuthentication(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LoginServiceProxyPrx proxy = LoginServiceProxyPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LoginAuthentication(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T, typename CT> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LoginServiceProxy_LoginAuthentication<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::LoginServiceProxy::begin_LoginAuthentication.
 */
template<class T, typename CT> Callback_LoginServiceProxy_LoginAuthenticationPtr
newCallback_LoginServiceProxy_LoginAuthentication(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LoginServiceProxy_LoginAuthentication<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_registerModule.
 */
template<class T>
class CallbackNC_RegisterService_registerModule : public Callback_RegisterService_registerModule_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RegisterService_registerModule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_registerModule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_registerModule<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_registerModule<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_registerModule.
 */
template<class T, typename CT>
class Callback_RegisterService_registerModule : public Callback_RegisterService_registerModule_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RegisterService_registerModule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_registerModule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T, typename CT> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_registerModule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_registerModule.
 */
template<class T, typename CT> Callback_RegisterService_registerModulePtr
newCallback_RegisterService_registerModule(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_registerModule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestImage.
 */
template<class T>
class CallbackNC_RegisterService_requestImage : public Callback_RegisterService_requestImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ImageData&);

    CallbackNC_RegisterService_requestImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_requestImage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(T* instance, void (T::*cb)(const ImageData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RegisterService_requestImage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 * Create a wrapper instance by calling ::MDScallMPSService::newCallback_RegisterService_requestImage.
 */
template<class T, typename CT>
class Callback_RegisterService_requestImage : public Callback_RegisterService_requestImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ImageData&, const CT&);

    Callback_RegisterService_requestImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RegisterServicePrx proxy = RegisterServicePrx::uncheckedCast(result->getProxy());
        ImageData ret;
        try
        {
            ret = proxy->end_requestImage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T, typename CT> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MDScallMPSService::RegisterService::begin_requestImage.
 */
template<class T, typename CT> Callback_RegisterService_requestImagePtr
newCallback_RegisterService_requestImage(T* instance, void (T::*cb)(const ImageData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RegisterService_requestImage<T, CT>(instance, cb, excb, sentcb);
}

}

namespace MPScallMDSService
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushUtcTime.
 */
template<class T>
class CallbackNC_MDSService_pushUtcTime : public Callback_MDSService_pushUtcTime_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushUtcTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushUtcTime<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushUtcTime.
 */
template<class T, typename CT>
class Callback_MDSService_pushUtcTime : public Callback_MDSService_pushUtcTime_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushUtcTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushUtcTime.
 */
template<class T, typename CT> Callback_MDSService_pushUtcTimePtr
newCallback_MDSService_pushUtcTime(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushUtcTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysOperPara.
 */
template<class T>
class CallbackNC_MDSService_pushSysOperPara : public Callback_MDSService_pushSysOperPara_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushSysOperPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSysOperPara<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSysOperPara.
 */
template<class T, typename CT>
class Callback_MDSService_pushSysOperPara : public Callback_MDSService_pushSysOperPara_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushSysOperPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSysOperPara.
 */
template<class T, typename CT> Callback_MDSService_pushSysOperParaPtr
newCallback_MDSService_pushSysOperPara(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSysOperPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSatPlatPara.
 */
template<class T>
class CallbackNC_MDSService_pushSatPlatPara : public Callback_MDSService_pushSatPlatPara_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushSatPlatPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushSatPlatPara<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushSatPlatPara.
 */
template<class T, typename CT>
class Callback_MDSService_pushSatPlatPara : public Callback_MDSService_pushSatPlatPara_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushSatPlatPara(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushSatPlatPara.
 */
template<class T, typename CT> Callback_MDSService_pushSatPlatParaPtr
newCallback_MDSService_pushSatPlatPara(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushSatPlatPara<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskInfo.
 */
template<class T>
class CallbackNC_MDSService_pushTaskInfo : public Callback_MDSService_pushTaskInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushTaskInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushTaskInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushTaskInfo.
 */
template<class T, typename CT>
class Callback_MDSService_pushTaskInfo : public Callback_MDSService_pushTaskInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushTaskInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushTaskInfo.
 */
template<class T, typename CT> Callback_MDSService_pushTaskInfoPtr
newCallback_MDSService_pushTaskInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushTaskInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_imageReady.
 */
template<class T>
class CallbackNC_MDSService_imageReady : public Callback_MDSService_imageReady_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_imageReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_imageReady<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_imageReady.
 */
template<class T, typename CT>
class Callback_MDSService_imageReady : public Callback_MDSService_imageReady_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_imageReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_imageReady.
 */
template<class T, typename CT> Callback_MDSService_imageReadyPtr
newCallback_MDSService_imageReady(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_imageReady<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushErrorLog.
 */
template<class T>
class CallbackNC_MDSService_pushErrorLog : public Callback_MDSService_pushErrorLog_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MDSService_pushErrorLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MDSService_pushErrorLog<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 * Create a wrapper instance by calling ::MPScallMDSService::newCallback_MDSService_pushErrorLog.
 */
template<class T, typename CT>
class Callback_MDSService_pushErrorLog : public Callback_MDSService_pushErrorLog_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MDSService_pushErrorLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPScallMDSService::MDSService::begin_pushErrorLog.
 */
template<class T, typename CT> Callback_MDSService_pushErrorLogPtr
newCallback_MDSService_pushErrorLog(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MDSService_pushErrorLog<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
